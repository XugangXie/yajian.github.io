<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小建儿的小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yajian.github.io/"/>
  <updated>2018-12-20T05:30:57.892Z</updated>
  <id>http://yajian.github.io/</id>
  
  <author>
    <name>小建儿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CART-分类与回归树</title>
    <link href="http://yajian.github.io/CART-%E5%88%86%E7%B1%BB%E4%B8%8E%E5%9B%9E%E5%BD%92%E6%A0%91/"/>
    <id>http://yajian.github.io/CART-分类与回归树/</id>
    <published>2018-12-13T02:32:10.000Z</published>
    <updated>2018-12-20T05:30:57.892Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;分类与回归树(classification and regression tree, CART)模型是应用比较广泛的决策树学习方法之一，它既可以用于分类也可以用于回归。CART算法使用二元切分递归地处理每个特征，如果特征值大于给定值就走左子树，否则就走右子树。</p><h1 id="最小二乘回归树生成算法"><a href="#最小二乘回归树生成算法" class="headerlink" title="最小二乘回归树生成算法"></a>最小二乘回归树生成算法</h1><h2 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h2><p>&emsp;&emsp;假设$X$和$Y$分别为输入和输出变量，并且$Y$是连续变量，给定训练数据集<br>$$D={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$$<br>生成对应的回归树。</p><p>&emsp;&emsp;一个回归树对应着输入空间(即特征空间)的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为$M$个单元$R_1,R_2,…,R_m$，并且在每个单元$R_m$上有一个固定的输出值$C_m$，于是回归树模型可以表示为</p><p>$$f(x) = \sum_{m=1}^{M}c_mI(x \in R_m)$$</p><p>其中函数$I$为指示函数。</p><p>&emsp;&emsp;当输入空间的划分确定时，可以用平方误差$\sum_{x_i \in R_m}(y_i-f(x_i))^2$来表示回归树对于训练数据的预测误差。用平方误差最小的准则求解每个单元上的最优输出值，可以发现单元$R_m$上的最优$\hat c_m$s是$R_m$上所有示例$x_i$对应的输出$y_i$的均值，即<br>$$\hat c_m=avg(y_i|x_i \in R_m)$$</p><p>&emsp;&emsp;上面内容讲述了在输入空间划分确定的情况下，如何衡量决策树的效果以及在效果最好的情况下反推每个区域输出值$c_m$。接下来我们来看如何划分输入空间。</p><p>&emsp;&emsp;首先，CART树是一棵二叉树，所以我们需要选择一个特征$x^{(j)}$和它的取值$s$，作为整个数据集的切分量和切分点，并定义由其切分的两个区域<br>$$R_1(j,s)=\lbrace x|x^{(j)} \leq s \rbrace和R_2(j,s)=\lbrace x|x^{(j)} \gt s \rbrace $$<br>然后寻找最优缺切分变量$j$和最优切分点$s$，即求解</p><p>$$min_{j,s}[min_{c1}\sum_{x_i \in R_1(j,s)}(y_i-c_1)^2+min_{c2}\sum_{x_i \in R_2(j,s)}(y_i-c_2)^2]$$</p><ul><li>注：这里是要找到使$R_1$数据的预测误差最小的$c_1$和使$R_2$数据的预测误差最小的$c_2$，之前说过使误差最小的取值就是分别取两个数据集的均值，然后还要保证$R_1$和$R_2$误差和最小。</li></ul><p>对于固定的输入变量$j$可以找到最优的切分点$s$：</p><p>$$\hat c_1=avg(y_i|x_i \in R_1(j,s)) 和 \hat c_2=avg(y_i|x_i \in R_2(j,s))$$</p><ul><li>注：简单讲，这里的$c_1$和$c_2$是每次按照切分点$s$分割成两波数据的均值，这里不明白的可以看后面的例子。</li></ul><p>&emsp;&emsp;遍历所有输入变量，找到最优的切分变量$j$，构成一对$(j,s)$，并依此将输入空间划分为两个区域。接着对每个区域重复上述划分过程，直到满足条件为止。这样就生成了一棵回归树，这样的回归树通常称为最小二乘回归树。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>&emsp;&emsp;上述数学描述比较晦涩，举个简单的例子，输入数据见下表</p><table><thead><tr><th style="text-align:center">x</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">5.56</td><td style="text-align:center">5.7</td><td style="text-align:center">5.91</td><td style="text-align:center">6.4</td><td style="text-align:center">6.8</td><td style="text-align:center">7.05</td><td style="text-align:center">8.9</td><td style="text-align:center">8.7</td><td style="text-align:center">9</td><td style="text-align:center">9.05</td></tr></tbody></table><ul><li>第一次划分</li></ul><p>&emsp;&emsp;由于只有$x$一个变量，因此最优切分变量为$x$。接下来假设9个切分点为$[1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5]$，计算每个切分点的输出值。如$s=1.5$时，$R_1={1},R_2={2,3,4,5,6,7,8,9,10}$，这两个区域的输出值分别为$c_1=5.56,c_2=\frac{1}{9}(5.7+5.91+6.4+6.8+7.05+8.9+8.7+9+9.05)=7.50$，所以有</p><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">1.5</th><th style="text-align:center">2.5</th><th style="text-align:center">3.5</th><th style="text-align:center">4.5</th><th style="text-align:center">5.5</th><th style="text-align:center">6.5</th><th style="text-align:center">7.5</th><th style="text-align:center">8.5</th><th style="text-align:center">9.5</th></tr></thead><tbody><tr><td style="text-align:center">$c_1$</td><td style="text-align:center">5.56</td><td style="text-align:center">5.63</td><td style="text-align:center">5.72</td><td style="text-align:center">5.89</td><td style="text-align:center">6.07</td><td style="text-align:center">6.24</td><td style="text-align:center">6.62</td><td style="text-align:center">6.88</td><td style="text-align:center">7.11</td></tr><tr><td style="text-align:center">$c_2$</td><td style="text-align:center">7.5</td><td style="text-align:center">7.73</td><td style="text-align:center">7.99</td><td style="text-align:center">8.25</td><td style="text-align:center">8.54</td><td style="text-align:center">8.91</td><td style="text-align:center">8.92</td><td style="text-align:center">9.03</td><td style="text-align:center">9.05</td></tr></tbody></table><p>接下来计算每个切分点的误差，如$s=1.5$时，$loss(s=1.5)=\frac{1}{2}(5.56-5.56)^2+\sum_{i=2}^{10}\frac{1}{2}(y_i-7.5)^2=0+15.72=15.72$，所以有</p><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">1.5</th><th style="text-align:center">2.5</th><th style="text-align:center">3.5</th><th style="text-align:center">4.5</th><th style="text-align:center">5.5</th><th style="text-align:center">6.5</th><th style="text-align:center">7.5</th><th style="text-align:center">8.5</th><th style="text-align:center">9.5</th></tr></thead><tbody><tr><td style="text-align:center">$loss(s)$</td><td style="text-align:center">15.72</td><td style="text-align:center">12.07</td><td style="text-align:center">8.36</td><td style="text-align:center">5.78</td><td style="text-align:center">3.91</td><td style="text-align:center">1.93</td><td style="text-align:center">8.01</td><td style="text-align:center">11.73</td><td style="text-align:center">15.74</td></tr></tbody></table><p>其中当$s=6.5$时，$loss(s)$最小，因此第一个划分变量是$j=x,s=6.5$。</p><ul><li><p>第二次划分</p><p>  &emsp;&emsp;第一个划分变量将数据集划分成了两部分即$R_1={1,2,3,4,5,6},R_2={7,8,9,10}$，接下来分别在$R_1,R_2$上进行划分。</p><ul><li>&emsp;&emsp;对于$R_1$</li></ul></li></ul><table><thead><tr><th style="text-align:center">x</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">5.56</td><td style="text-align:center">5.7</td><td style="text-align:center">5.91</td><td style="text-align:center">6.4</td><td style="text-align:center">6.8</td><td style="text-align:center">7.05</td></tr></tbody></table><p>&emsp;&emsp;取切分点$[1.5,2.5,3.5,4.5,5.5]$，对应的输出值为</p><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">1.5</th><th style="text-align:center">2.5</th><th style="text-align:center">3.5</th><th style="text-align:center">4.5</th><th style="text-align:center">5.5</th></tr></thead><tbody><tr><td style="text-align:center">$c_1$</td><td style="text-align:center">5.56</td><td style="text-align:center">5.63</td><td style="text-align:center">5.72</td><td style="text-align:center">5.89</td><td style="text-align:center">6.07</td></tr><tr><td style="text-align:center">$c_2$</td><td style="text-align:center">6.37</td><td style="text-align:center">6.54</td><td style="text-align:center">6.75</td><td style="text-align:center">6.93</td><td style="text-align:center">7.05</td></tr></tbody></table><p>&emsp;&emsp;误差为</p><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">1.5</th><th style="text-align:center">2.5</th><th style="text-align:center">3.5</th><th style="text-align:center">4.5</th><th style="text-align:center">5.5</th></tr></thead><tbody><tr><td style="text-align:center">$loss(s)$</td><td style="text-align:center">1.3087</td><td style="text-align:center">0.754</td><td style="text-align:center">0.2771</td><td style="text-align:center">0.4368</td><td style="text-align:center">1.0644</td></tr></tbody></table><p>所以$s=3.5$时，$loss(s)$最小</p><p>&emsp;&emsp;假设在生成3个区域后停止划分，那么最终生成的回归树如下：</p><p>$$<br>T=\begin{cases}<br>5.72 \quad x \le 3.5 \\<br>6.75 \quad 3.5 \lt x \leq 6.5 \\<br>8.91 \quad x \lt 6.5\\<br>\end{cases}<br>$$</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(path)</span>:</span></span><br><span class="line">    dataMat = []</span><br><span class="line">    fr = open(path, <span class="string">'rb'</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        currLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        fltLine = map(float, currLine)</span><br><span class="line">        dataMat.append(fltLine)</span><br><span class="line">    <span class="keyword">return</span> mat(dataMat)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以value为分界点切分数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binSplitDataSet</span><span class="params">(dataSet, feature, value)</span>:</span></span><br><span class="line">    mat0 = dataSet[nonzero(dataSet[:, feature] &gt; value)[<span class="number">0</span>], :]</span><br><span class="line">    mat1 = dataSet[nonzero(dataSet[:, feature] &lt;= value)[<span class="number">0</span>], :]</span><br><span class="line">    <span class="keyword">return</span> mat0, mat1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算叶子结点中数据的均值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regLeaf</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> mean(dataSet[:, <span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算误差，即数据集的平方误差，这里使用方差乘以总个数计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regErr</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> var(dataSet[:, <span class="number">-1</span>]) * shape(dataSet)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二元切分选择分裂点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestSplit</span><span class="params">(dataSet, leafType=regLeaf, errType=regErr, ops=<span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span>)</span>:</span></span><br><span class="line">    tolS = ops[<span class="number">0</span>]</span><br><span class="line">    tolN = ops[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> len(set(dataSet[:, <span class="number">-1</span>].T.tolist()[<span class="number">0</span>])) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span>, leafType(dataSet)</span><br><span class="line">    m, n = shape(dataSet)</span><br><span class="line">    S = errType(dataSet)</span><br><span class="line">    bestS = inf</span><br><span class="line">    bestIndex = <span class="number">0</span></span><br><span class="line">    bestValue = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> featIndex <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> splitVal <span class="keyword">in</span> set(dataSet[:, featIndex].T.tolist()[<span class="number">0</span>]):</span><br><span class="line">            <span class="comment"># 切分数据集</span></span><br><span class="line">            mat0, mat1 = binSplitDataSet(dataSet, featIndex, splitVal)</span><br><span class="line">            <span class="comment"># 判断切分后的数据集的条数是否满足要求</span></span><br><span class="line">            <span class="keyword">if</span> (shape(mat0)[<span class="number">0</span>] &lt; tolN) <span class="keyword">or</span> (shape(mat1)[<span class="number">0</span>] &lt; tolN):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算两个数据集的误差</span></span><br><span class="line">            newS = errType(mat0) + errType(mat1)</span><br><span class="line">            <span class="comment"># 选取误差最小的切分方式</span></span><br><span class="line">            <span class="keyword">if</span> newS &lt; S:</span><br><span class="line">                bestIndex = featIndex</span><br><span class="line">                bestValue = splitVal</span><br><span class="line">                bestS = newS</span><br><span class="line">    <span class="comment"># 如果误差已经小于要求的误差</span></span><br><span class="line">    <span class="keyword">if</span> S - bestS &lt; tolS:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span>, leafType(dataSet)</span><br><span class="line">    mat0, mat1 = binSplitDataSet(dataSet, bestIndex, bestValue)</span><br><span class="line">    <span class="comment"># 如果不满足条数要求，不再继续分裂，返回结点的值</span></span><br><span class="line">    <span class="keyword">if</span> (shape(mat0)[<span class="number">0</span>] &lt; tolN) <span class="keyword">or</span> (shape(mat1)[<span class="number">0</span>] &lt; tolN):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span>, leafType(dataSet)</span><br><span class="line">    <span class="keyword">return</span> bestIndex, bestValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet, leafType=regLeaf, errType=regErr, ops=<span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 选择最佳分裂点</span></span><br><span class="line">    feat, val = chooseBestSplit(dataSet, leafType, errType, ops)</span><br><span class="line">    <span class="keyword">if</span> feat == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    retTree = &#123;&#125;</span><br><span class="line">    retTree[<span class="string">'spInd'</span>] = feat</span><br><span class="line">    retTree[<span class="string">'spVal'</span>] = val</span><br><span class="line">    lSet, rSet = binSplitDataSet(dataSet, feat, val)</span><br><span class="line">    <span class="comment"># 左子树</span></span><br><span class="line">    retTree[<span class="string">'left'</span>] = createTree(lSet, leafType, errType, ops)</span><br><span class="line">    <span class="comment"># 柚子树</span></span><br><span class="line">    retTree[<span class="string">'right'</span>] = createTree(rSet, leafType, errType, ops)</span><br><span class="line">    <span class="keyword">return</span> retTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    data = loadDataSet(<span class="string">'./data.txt'</span>)</span><br><span class="line">    tree = createTree(data)</span><br><span class="line">    <span class="keyword">print</span> tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>代码详见<a href="https://github.com/yajian/machine_learning/blob/master/tree/cart/regTrees.py" target="_blank" rel="noopener">CART</a></p><ul><li>注：此处代码参考《机器学习实战》p161-p164，原书代码中存在错误，这里进行了修改。</li></ul><h1 id="分类树生成算法"><a href="#分类树生成算法" class="headerlink" title="分类树生成算法"></a>分类树生成算法</h1><p>&emsp;&emsp;分类树使用基尼指数选择最优特征，同时决定最优二值切分点。</p><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>&emsp;&emsp;基尼指数的定义如下，假设有$K$个分类，样本点属于第$k$类的概率为$p_k$，则概率分布的基尼指数为<br>$$<br>    Gini(p) = \sum_{k=1}^{K}p_k(1-p_k)=1-\sum_{k=1}^{K}p^2_k<br>$$</p><p>&emsp;&emsp;对于给定的样本集合$D$，其基尼指数为<br>$$<br>    Gini(D)=1-\sum_{i=1}^{K}(\frac{|C_k|}{|D|})^2<br>$$<br>其中，$C_k$是$D$中属于第$k$类的样本子集，$K$是类的个数。</p><p>&emsp;&emsp;如果样本集合$D$根据特征$A$是否取某一可能值$a$呗分割成$D_1$和$D_2$两部分，即<br>$$<br>    D_1 = {(x,y) \in D|A(x)=a}\\<br>    D_2 = D-D_1<br>$$<br>则在特征$A$的条件下，集合$D$的基尼指数定义为<br>$$<br>    Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)<br>$$<br>基尼指数$Gini(D)$表示集合$D$的不确定性，基尼指数$Gini(D,A)$表示经$A=a$分割后集合$D$的不确定性。基尼指数越大，样本集合的不确定性也就越大，这一点和熵一致。</p><ul><li>注：CART分类树为什么要使用基尼指数作为选择最优特征的标准呢？因为基尼指数不仅拥有与熵类似的性质，而且计算简便，不用使用log函数。</li></ul><h2 id="生成算法"><a href="#生成算法" class="headerlink" title="生成算法"></a>生成算法</h2><p>&emsp;&emsp;输入：训练数据集$D$，停止计算的条件；</p><p>&emsp;&emsp;输出：CART决策树</p><p>&emsp;&emsp;根据训练数据集，从根节点开始，递归地对每个结点进行以下操作，构建二叉决策树</p><ol><li>设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数。此时对每个特征$A$，对其可能取值的每个值$a$，根据样本点对$A=a$的测试为“是”或”否“将$D$分割成$D_1$和$D_2$两部分，并计算$A=a$的基尼指数。</li><li>在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征和最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据依特征分配到两个子结点中。</li><li>对两个子结点递归地调用1、2，直至满足停止条件</li><li>生成CART决策树</li></ol><p>&emsp;&emsp;算法停止条件是结点中的样本个数小于预定阈值，或者样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>&emsp;&emsp;数据集合如下:</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">年龄</th><th style="text-align:center">有工作</th><th style="text-align:center">有自己的房子</th><th style="text-align:center">信贷情况</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青年</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">青年</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">一般</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">中年</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">老年</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">老年</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">老年</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">老年</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">老年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr></tbody></table><p>&emsp;&emsp;分别以$A_1$、$A_2$、$A_3$、$A_4$表示年龄、有工作、有自己的房子和信贷4个特征。</p><p>&emsp;&emsp;求特征$A_1$的基尼指数，以1，2，3表示年龄的值为青年、中年、老年</p><p>$$<br>    Gini(D,A_1=1) = \frac{5}{15}[2 \times \frac{2}{5} \times (1-\frac{2}{5})] + \frac{10}{15}[2 \times \frac{7}{10} \times (1-\frac{7}{10})]=0.44\\<br>    Gini(D,A_1=2) = \frac{5}{15}[2\times\frac{3}{5}\times(1-\frac{3}{5})] + \frac{10}{15}[2\times\frac{6}{10}\times(1-\frac{6}{10})]=0.48\\<br>    Gini(D,A_1=3) = \frac{5}{15}[2\times\frac{4}{5}\times(1-\frac{4}{5})] + \frac{10}{15}[2\times\frac{5}{10}\times(1-\frac{5}{10})]=0.44<br>$$<br>其中$Gini(D,A_1=1)$和$Gini(D,A_1=3)$最小，所以$A_1=1$和$A_1=3$均可做为$A_1$的最优切分点</p><p>&emsp;&emsp;求特征$A_2$的基尼指数，以1，2表示有工作和没有工作<br>$$<br>    Gini(D,A_2=1) = \frac{5}{15}[2\times\frac{5}{5}\times(1-\frac{5}{5})] + \frac{10}{15}[2\times\frac{4}{10}\times(1-\frac{4}{10})]=0.32<br>$$<br>$A_2$只有一个切分点即$A_2=1$</p><p>&emsp;&emsp;求特征$A_3$的基尼指数，以1，2表示有房子和没有房子<br>$$<br>    Gini(D,A_3=1) = \frac{6}{15}[2\times\frac{6}{6}\times(1-\frac{6}{6})] + \frac{9}{15}[2\times\frac{3}{9}\times(1-\frac{3}{9})]=0.27<br>$$<br>$A_3$只有一个切分点即$A_3=1$</p><p>&emsp;&emsp;求特征$A_4$的基尼指数，以1，2，3表示信贷情况为非常好、好和一般<br>$$<br>    Gini(D,A_4=1) = \frac{4}{15}[2\times\frac{4}{4}\times(1-\frac{4}{4})] + \frac{11}{15}[2\times\frac{6}{11}\times(1-\frac{6}{11})]=0.36\\<br>    Gini(D,A_4=2) = \frac{6}{15}[2\times\frac{4}{6}\times(1-\frac{4}{6})] + \frac{9}{15}[2\times\frac{5}{9}\times(1-\frac{5}{9})]=0.47\\<br>    Gini(D,A_4=3) = \frac{5}{15}[2\times\frac{1}{5}\times(1-\frac{1}{5})] + \frac{10}{15}[2\times\frac{8}{10}\times(1-\frac{8}{10})]=0.32<br>$$</p><p>其中$Gini(D,A_4=3)$最小，所以$A_4=3$为$A_4$的最优切分点</p><p>&emsp;&emsp;在4个特征中，$Gini(D,A_3=1)=0.27$最小，所以选择$A_3$为最优特征，$A_3=1$为其最优切分点。其中$A_3=1$的结点包含数据4、8、9、10、11，$A_3 \neq 1$结点包含数据1，2，3，5，6，7，13，14，15。$A_3=1$结点内数据类别相同，所以形成叶子结点。对$A_3 \neq 1$结点继续重复上述过程。</p><p>&emsp;&emsp;数据如下</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">年龄</th><th style="text-align:center">有工作</th><th style="text-align:center">信贷情况</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青年</td><td style="text-align:center">是</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">老年</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">老年</td><td style="text-align:center">是</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">老年</td><td style="text-align:center">是</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">老年</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr></tbody></table><p>&emsp;&emsp;求特征$A_1$的基尼指数<br>$$<br>    Gini(D,A_1=1) = \frac{4}{10}[2\times\frac{1}{4}\times(1-\frac{1}{4})] + \frac{6}{10}[2\times\frac{3}{6}\times(1-\frac{3}{6})]=0.45\\<br>    Gini(D,A_1=2) = \frac{2}{10}[2\times\frac{0}{2}\times(1-\frac{0}{2})] + \frac{8}{10}[2\times\frac{4}{8}\times(1-\frac{4}{8})]=0.4\\<br>    Gini(D,A_1=3) = \frac{4}{10}[2\times\frac{3}{4}\times(1-\frac{3}{4})] + \frac{6}{10}[2\times\frac{1}{6}\times(1-\frac{1}{6})]=0.32<br>$$<br>其中$Gini(D,A_1=3)$最小，所以$A_1=3$是$A_1$的最优切分点</p><p>&emsp;&emsp;求特征$A_2$的基尼指数<br>$$<br>    Gini(D,A_2=1) = \frac{3}{10}[2\times\frac{3}{3}\times(1-\frac{3}{3})] + \frac{7}{10}[2\times\frac{1}{7}\times(1-\frac{1}{7})]=0.17<br>$$<br>$A_2$只有一个切分点即$A_2=1$</p><p>&emsp;&emsp;求特征$A_4$的基尼指数<br>$$<br>    Gini(D,A_4=1) = \frac{1}{10}[2\times\frac{1}{1}\times(1-\frac{1}{1})] + \frac{9}{10}[2\times\frac{3}{9}\times(1-\frac{3}{9})]=0.4\\<br>    Gini(D,A_4=2) = \frac{5}{10}[2\times\frac{3}{5}\times(1-\frac{3}{5})] + \frac{5}{10}[2\times\frac{1}{5}\times(1-\frac{1}{5})]=0.4\\<br>    Gini(D,A_4=3) = \frac{4}{10}[2\times\frac{0}{0}\times(1-\frac{0}{0})] + \frac{6}{10}[2\times\frac{4}{6}\times(1-\frac{4}{6})]=0.27<br>$$</p><p>其中$Gini(D,A_4=3)$最小，所以$A_4=3$为$A_4$的最优切分点</p><p>&emsp;&emsp;在4个特征中，$Gini(D,A_2=1)=0.17$最小，所以选择$A_2$为最优特征，$A_2=1$为其最优切分点。其中$A_2=1$的结点包含数据3、13、14，$A_3 \neq 1$结点包含数据1、2、5、6、7、12、15。$A_2=1$结点内数据类别相同，所以形成叶子结点。对$A_2 \neq 1$结点内数据类别相同，所以形成叶子结点。</p><p>&emsp;&emsp;到此，CART树生成完毕。可以发现与之前按照ID3算法所生成的决策树一样，如下图。</p><div align="center"><br>    <img src="/CART-分类与回归树/决策树.png" alt="决策树模型结构"><br></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>机器学习实战，人民邮电出版社</li><li>统计学习方法，清华大学出版社</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;分类与回归树(classification and regression tree, CART)模型是应用比较广泛的决策树学习方法之一，它既可以用于分类也可以用于回归。CART算法使用二元切分递归地处理每个特征，如果特征值大于给定值就走左子树，否则就
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yajian.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="树模型" scheme="http://yajian.github.io/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>决策树</title>
    <link href="http://yajian.github.io/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://yajian.github.io/决策树/</id>
    <published>2018-12-10T13:00:03.000Z</published>
    <updated>2018-12-20T03:41:16.887Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;决策树(decision tree)是一种多功能的机器学习算法，它可以实现分类和回归任务，同时也是随机森林的重要组成部分，本篇博客主要讨论用于分类的决策树。</p><p>&emsp;&emsp;分类型决策树是一种描述对实例进行分类的树形结构。决策树由结点（node）和有向边（directed edge）组成。结点有两种类型：内部结点（internal node）和叶结点（leaf node）。内结点表示一个特征，叶子结点表示一个类别。</p><h1 id="相关数学概念"><a href="#相关数学概念" class="headerlink" title="相关数学概念"></a>相关数学概念</h1><h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><p>&emsp;&emsp;在将实例分配到子结点的过程中需要选择一个度量条件来判断该实例属于哪个子结点，常见的方法是用信息熵作为度量条件。</p><p>&emsp;&emsp;在信息论中，熵（entropy）表示随机变量不确定性的度量，设$X$是一个取有限个值的离散随机变量，其概率分布为<br>$$P(X=x_i)=p_i, i=1,2,…,n$$<br>则随机变量$X$的熵的定义为<br>$$<br>H(X)=-\sum_{i=1}^{n}p_ilog_{2}p_i<br>\tag{1}<br>$$<br>若$p_i=0$，则定义$0log0=0$。熵越大，说明随机变量的不确定性越大。</p><h2 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h2><p>&emsp;&emsp;设有随机变量(X,Y)，其联合概率分布为<br>$$P(X=x_i,Y=y_i)=p_{ij}, i=1,2,…,n;j=1,2,…,m$$<br>条件熵H(Y|X)表示在已知随机变量$X$的条件下随机变量$Y$的不确定性。随机变量$X$给定的条件下随机变量$Y$的条件熵H(Y|X)，定义为$X$给定条件下$Y$的条件概率分布的熵对$X$的数学期望。<br>$$P(Y|X)=\sum_{i=1}^{n}p_iH(Y|X=x_i)$$<br>其中$p_i=P(X=x_i)$</p><p>&emsp;&emsp;当熵和条件熵中的概率由数据估计（特别是极大似然估计）得到时，所对应的熵和条件熵分别称为经验熵(empirical entropy)和经验条件熵(empirical conditional entropy).</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>&emsp;&emsp;信息增益(information gain)表示得知特征$X$的信息而使得类别$Y$的信息不确定性减少的程度。</p><p>&emsp;&emsp;特征A对训练数据集D的信息增益$g(D,A)$，定义为集合D的经验熵$H(D)$与特征A给定的条件下D的经验条件熵$H(D|A)$之差，即<br>$$g(D,A)=H(D)-H(D|A)$$</p><p>&emsp;&emsp;一般地，熵$H(Y)$与条件熵$H(Y|X)$之差称为互信息，决策树中的信息增益等价于训练数据集中类别和特征的互信息。</p><h2 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h2><p>&emsp;&emsp;特征A对训练数据集D的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集$D$的经验熵$H(D)$之比<br>$$g_R(D,A)=\frac{g(D,A)}{H(D)}$$</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;决策树在建模过程中使用信息增益准则选择特征，给定训练集$D$和特征$A$，经验熵$H(D)$表示对数据集$D$进行分类的不确定性。而经验条件熵$H(D|A)$表示在特征$A$给定的条件下对数据集$D$进行分类的不确定性，它们的差即信息增益，表示由于特征$A$而使得对数据集$D$的分类的不确定性减少的程度。显然，对于数据集$D$而言，信息增益依赖于特征，不同的特征具有不同的信息增益，信息增益大的特征具有更强的分类能力。</p><p>&emsp;&emsp;根据信息增益准则的特征选择方法是：对训练数据集$D$，计算其每个特征的信息增益，并比较它们的大小，选择信息增益大的特征。</p><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><p>&emsp;&emsp;设训练数据集为$D$，$|D|$表示其样本容量，即样本个数。设有$K$个类$C_k，k=1,2,…,K$，$|C_k|$为属于$C_k$的样本个数，$\sum_{k=1}^{K}|C_k|=|D|$。设特征$A$有$n$个不同的取值${a_1,a_2,…,a_n}$，根据特征$A$的取值将$D$划分为n个子集$D_1,D_2,…,D_n$，$|D_i|$为$D_i$的样本个数，$\sum_{k=1}^{n}|D_i|=|D|$。记子集$D_i$中属于类$C_k$的样本的集合为$D_{ik}$，记$D_{ik}=D_i \cap C_k$，$|D_{ik}|$为$D_{ik}$的样本个数。</p><p>&emsp;&emsp;ID3算法如下</p><ul><li>输入： 训练数据集$D$，特征集$A$，阈值$\epsilon$</li><li>输出： 决策树$T$</li></ul><ol><li>若$D$中所有实例属于同一类别$C_k$，则$T$为单结点树，并将类$C_k$作为该结点的类标记，返回$T$；</li><li>若$A=\emptyset$，则$T$为单点树，将$D$中实例数最多的类$C_k$作为该结点的类标记，返回$T$；</li><li><p>否则，如下计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$</p><ol><li>计算数据集$D$的经验熵<br>$$H(D)=-\sum_{k=1}^{K}\frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}$$ </li><li>计算特征集$A$对数据集$D$的经验条件熵<br>$$H(D|A)=\sum_{i=1}^{n}\frac{|D_i|}{|D|}H(D_i)=\sum_{i=1}^{n}[\frac{|D_i|}{|D|}\sum_{k=1}^{K}\frac{|D_{ik}|}{|D_{i}|}log_2\frac{|D_{ik}|}{|D_{i}|}]$$</li><li>计算信息增益<br>$$g(D,A)=H(D) - H(D|A)$$</li></ol></li><li><p>如果$A_g$小于阈值$\epsilon$，则置$T$为单点树，将$D$中实例数最多的类$C_k$作为该结点的类标记，返回$T$；</p></li><li>否则，对$A_g$的每一个值$a_i$，按照$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例最大的类作为标记，构建子结点，由结点和子结点构成树$T$，返回$T$</li><li>对第$i$个子结点，以$D_i$为训练集，以$A_i-{A_g}$为特征集，递归地调用步骤1-5，得到子树$T_i$，返回$T_i$</li></ol><h2 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h2><p>&emsp;&emsp;C4.5算法和ID3算法类似，C4.5算法对ID3算法进行了改进，在生成模型的过程中采用信息增益比来选择特征。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>&emsp;&emsp;以贷款申请数据为例讲解决策树的生成过程，采用ID3算法。</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">年龄</th><th style="text-align:center">有工作</th><th style="text-align:center">有自己的房子</th><th style="text-align:center">信贷情况</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青年</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">青年</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">一般</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">青年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">中年</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">中年</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">老年</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">老年</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">老年</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">老年</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">非常好</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">老年</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">一般</td><td style="text-align:center">否</td></tr></tbody></table><ol><li>计算经验熵$H(D)$<br> $$H(D)=-\frac{6}{15}log_2\frac{6}{15}-\frac{9}{15}log_2\frac{9}{15}=0.971$$</li><li><p>计算各特征对数据集$D$的信息增益</p><ul><li>年龄<br>$$<br>\begin{split}<br>g(D,A_1)&amp;=H(D) - [\frac{5}{15}H(D_1)+\frac{5}{15}H(D_2)+\frac{5}{15}H(D_3)]\\<br>&amp;= 0.971 - {\frac{5}{15}[-\frac{2}{5}log_2\frac{2}{5}-\frac{3}{5}log_2\frac{3}{5}]+<br>\frac{5}{15}[-\frac{3}{5}log_2\frac{3}{5}-\frac{2}{5}log_2\frac{2}{5}]+<br>\frac{5}{15}[-\frac{4}{5}log_2\frac{4}{5}-\frac{1}{5}log_2\frac{1}{5}]}\\<br>&amp;=0.971-0.888\\<br>&amp;=0.083<br>\end{split}<br>$$</li><li>有工作<br>$$<br>\begin{split}<br>g(D,A_2)&amp;=H(D) - [\frac{5}{15}H(D_1)+\frac{10}{15}H(D_2)]\\<br>&amp;= 0.971 - {\frac{5}{15} \times 0+<br>\frac{10}{15}[-\frac{6}{10}log_2\frac{6}{10}-\frac{4}{10}log_2\frac{4}{10}]}\\<br>&amp;=0.971-0.647\\<br>&amp;=0.324<br>\end{split}<br>$$</li><li>有自己的房子<br>$$<br>\begin{split}<br>g(D,A_3)&amp;=H(D) - [\frac{6}{15}H(D_1)+\frac{9}{15}H(D_2)]\\<br>&amp;= 0.971 - {\frac{6}{15} \times 0+<br>\frac{9}{15}[-\frac{3}{9}log_2\frac{3}{9}-\frac{6}{9}log_2\frac{6}{9}]}\\<br>&amp;=0.971-0.551\\<br>&amp;=0.420<br>\end{split}<br>$$</li><li>信贷情况<br>$$<br>\begin{split}<br>g(D,A_3)&amp;=H(D) - [\frac{5}{15}H(D_1)+\frac{6}{15}H(D_2)+\frac{4}{15}H(D_2)]\\<br>&amp;= 0.971 - {\frac{5}{15}[-\frac{1}{5}log_2\frac{1}{5}-\frac{4}{5}log_2\frac{4}{5}] +<br>\frac{6}{15}[-\frac{4}{6}log_2\frac{4}{6}-\frac{2}{6}log_2\frac{2}{6}] +<br>\frac{4}{15} \times 0  }\\<br>&amp;=0.971-0.608\\<br>&amp;=0.363<br>\end{split}<br>$$<br>&emsp;&emsp;综上，特征$A_3$（有自己的房子）的信息增益值最大，所以选择$A_3$作为根节点的特征。接下来将数据集$D$划分为两个子集$D_1$($A_3$=是)、$D_2$($A_3$=否)，分别进行下一轮的信息增益筛选。</li></ul></li></ol><ol start="3"><li>进入子集$D_1$($A_3$=是)，由于该子集中只有一个类别，所以形成叶子结点，结点的标记就是类别。</li><li><p>进入子集$D_2$($A_3$=否)，数据如下</p><ul><li><p>计算经验熵<br>$$H(D_2)=-\frac{6}{9}log_2\frac{6}{9}-\frac{3}{9}log_2\frac{3}{9}=0.918$$</p></li><li><p>年龄特征信息增益<br>$$<br>\begin{split}<br>g(D_2,A_1)&amp;=H(D) - [\frac{4}{9}H(D_1)+\frac{2}{9}H(D_2)+\frac{3}{9}H(D_3)]\\<br>&amp;= 0.971 - {\frac{4}{9}[-\frac{3}{4}log_2\frac{3}{4}-\frac{1}{4}log_2\frac{1}{4}]+<br>\frac{2}{9}\times0+<br>\frac{3}{9}[-\frac{2}{3}log_2\frac{2}{3}-\frac{1}{3}log_2\frac{1}{3}]}\\<br>&amp;=0.971-0.667\\<br>&amp;=0.251<br>\end{split}<br>$$</p></li><li><p>有工作特征信息增益</p></li></ul><p>$$<br> \begin{split}<br> g(D_2,A_2)&amp;=H(D) - [\frac{6}{9}H(D_1)+\frac{3}{9}H(D_2)]\\<br> &amp;= 0.971 - [\frac{6}{9}\times0+\frac{3}{9} \times 0]\\<br> &amp;= 0.918-0\\<br> &amp;=0.918<br> \end{split}<br> $$</p><ul><li><p>信贷情况特征信息增益</p><p>  $$<br>\begin{split}<br>g(D_2,A_4)&amp;=H(D) - [\frac{4}{9}H(D_1)+\frac{4}{9}H(D_2)+\frac{1}{9}H(D_3)]\\<br>&amp;= 0.971 - {\frac{4}{9}\times0+<br>\frac{4}{9}[-\frac{2}{4}log_2\frac{2}{4}-\frac{2}{4}log_2\frac{2}{4}]+<br>\frac{1}{9}\times0}\\<br>&amp;=0.918-0.444\\<br>&amp;=0.474<br>\end{split}<br>$$<br>&emsp;&emsp;综上，特征$A_2$（有工作）的信息增益值最大，所以选择$A_2$作为该结点的特征。接下来将数据集$D_2$划分为两个子集$D_{21}$($A_2$=是)、$D_{22}$($A_2$=否)，分别进行下一轮的信息增益筛选。</p></li></ul></li><li><p>进入子集$D_{21}$($A_2$=是)，由于该子集中只有一个类别，所以形成叶子结点，结点的标记就是类别</p></li><li>进入子集$D_{22}$($A_2$=否)，由于该子集中只有一个类别，所以形成叶子结点，结点的标记就是类别</li></ol><p>&emsp;&emsp;最终产生的决策树模型如下图所示</p><div align="center"><br>    <img src="/决策树/决策树.png" alt="决策树模型结构"><br></div><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">import</span> pygraphviz <span class="keyword">as</span> pgv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="comment"># 数据集总条数</span></span><br><span class="line">    numEntries = len(dataSet)</span><br><span class="line">    labelCount = &#123;&#125;</span><br><span class="line">    <span class="comment"># 计算每个类别样本的数量</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]</span><br><span class="line">        labelCount[currentLabel] = labelCount.get(currentLabel, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCount:</span><br><span class="line">        <span class="comment"># 计算每个类别出现的概率</span></span><br><span class="line">        prob = float(labelCount[key]) / numEntries</span><br><span class="line">        <span class="comment"># 计算信息熵</span></span><br><span class="line">        shannonEnt -= prob * log(prob, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># 挑选第axis个特征的值为value的数据</span></span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeature = featVec[:axis]</span><br><span class="line">            reducedFeature.append(featVec[axis + <span class="number">1</span>:])</span><br><span class="line">            <span class="comment"># 注意，此处是extend，不是append</span></span><br><span class="line">            retDataSet.extend(reducedFeature)</span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="comment"># 特征数量，由于最后一个是标签，所以减1</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算经验熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    bestFeature = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</span><br><span class="line">        <span class="comment"># 把第i个特征全部挑出</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        <span class="comment"># 第i个特征有几个不同的特征值</span></span><br><span class="line">        uniqueVals = set(featList)</span><br><span class="line">        <span class="comment"># 条件经验熵</span></span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            <span class="comment"># 把特征值等于value的数据挑出</span></span><br><span class="line">            subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">            <span class="comment"># 计算特征值等于value的数据占总样本的比例</span></span><br><span class="line">            prob = len(subDataSet) / float(len(dataSet))</span><br><span class="line">            <span class="comment"># 计算经验条件熵</span></span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)</span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="keyword">if</span> infoGain &gt; bestInfoGain:</span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        classCount[vote] = classCount.get(vote, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    sortedClassCount = sorted(classCount.iteritems(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet, labels)</span>:</span></span><br><span class="line">    classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    myTree = &#123;bestFeatLabel: &#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span> (labels[bestFeat])</span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = set(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subLabels = labels[:]</span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet = [[<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'yes'</span>],</span><br><span class="line">               [<span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'no'</span>],</span><br><span class="line">               [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'no'</span>]]</span><br><span class="line">    labels = [<span class="string">'no surfacing'</span>, <span class="string">'flippers'</span>]</span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    dataSet, labels = createDataSet()</span><br><span class="line">    tree = createTree(dataSet, labels)</span><br><span class="line">    <span class="keyword">print</span> tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>机器学习实战，人民邮电出版社</li><li>统计学习方法，清华大学出版社</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;决策树(decision tree)是一种多功能的机器学习算法，它可以实现分类和回归任务，同时也是随机森林的重要组成部分，本篇博客主要讨论用于分类的决策树。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;分类型决策树是一种描述对实例进行分类的树形结构。决策树
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yajian.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="树模型" scheme="http://yajian.github.io/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归</title>
    <link href="http://yajian.github.io/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://yajian.github.io/逻辑回归/</id>
    <published>2018-12-06T06:15:09.000Z</published>
    <updated>2018-12-20T03:42:27.917Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;机器学习主要解决两类问题：回归和分类，上篇文章中的线性回归模型是回归模型的一种，但并不能用于分类问题，本文将介绍一种可以用于分类问题的回归算法–logistic回归。</p><p>&emsp;&emsp;利用logistic回归进行分类的主要思想是：估算某个实例属于特定类别的概率，如果预估概率超过50%，则属于该类别；反之，属于其他类别，这样形成了一个简单的二元分类器。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h2><p>&emsp;&emsp;我们希望能找到一种根据输入值输出0，1分类的函数，脑海中闪现的第一个函数应该就是单位阶跃函数，即<br>$$<br>\delta(x)=<br>    \begin{cases}<br>        0, &amp; x \leq 0; \\<br>        1, &amp; x&gt;0.<br>    \end{cases}<br>$$<br>但是该函数在$x=0$处不可导，对于公式推导来说有很大问题，所以大牛们找到了sigmoid函数来代替阶跃函数。</p><p>&emsp;&emsp;Sigmoid函数公式如下</p><p>$$<br>    f(x)=\frac{1}{1+e^{-x}}<br>    \tag{1}<br>$$</p><p>其函数图像如下所示</p><div align="center"><br>    <img src="/逻辑回归/sigmoid.png" width="450" height="300" title="sigmoid函数图像"><br></div><h2 id="logistic回归模型"><a href="#logistic回归模型" class="headerlink" title="logistic回归模型"></a>logistic回归模型</h2><p>&emsp;&emsp;将公式1推广到多维场景：给每个特征都乘以一个回归系数并相加，即$z=\theta_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+……+\theta_{n}x_{n}=\theta ^{T}x$（线性回归），然后将总和带入sigmoid函数中得到<br>$$<br>h_{\theta}\left(x \right)=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-\theta ^{T}x}}<br>\tag{2}<br>$$<br>&emsp;&emsp;所以线性回归的的结果被映射到了sigmoid函数中。在sigmoid函数图像中可以看出，其函数值介于0～1，中间值为0.5，因此$h_{\theta}\left(x \right)$的输出可以看作分类的概率。当$h_{\theta}\left(x \right)&gt;0.5$，说明$x$属于A类；反之，$h_{\theta}\left(x \right)&lt;0.5$，则$x$属于B类。</p><h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><p>&emsp;&emsp;对于给定的数据集$T={(x_1,y_1),(x_2,y_2),…(x_n,y_n)}$，其中$x_i \in R^n$，$y_i \in {0,1}$。分类结果为1的概率表示为<br>$$<br>        P(y=1|x;\theta)=h_\theta(x)<br>$$<br>分类结果为0的概率表示为<br>$$<br>        P(y=0|x;\theta)=1-h_\theta(x)<br>$$<br>将其合并则有<br>$$<br>p(y|x;\theta)=h_\theta(x_i) ^{y_i}(1-h_\theta(x))^{1-y_i}<br>$$<br>因为m个样本互相独立，所以其联合分布可以看作各个样本概率之积，则似然函数为<br>$$<br>    L(\theta) = \prod_{i=1}^{n}p(y_i|x_i;\theta)=\prod_{i=1}^{n} [h_\theta(x_i)]^{y_i}[1-h_\theta(x_i)]^{1-y_i}<br>$$<br>取对数似然<br>$$<br>l(\theta) =\sum_{i=1}^{n} y_ilog[h_\theta(x_i)]+(1-y_i)log[1-h_\theta(x)]<br>\tag{3}<br>$$<br>当$l\left(\theta \right)$取最大值时，$\theta$的值为最终的解。求$l\left(\theta \right)$对$\theta$的导数 </p><p>$$<br>\begin{split}<br>    l^{‘}(\theta)&amp;=\sum_{i=1}^{n} [\frac{y_i}{h_\theta(x_i)}-\frac{1-y_i}{1-h_\theta(x_i)}] \cdot h^{‘}_\theta(x_i)\\<br>    &amp;=\sum_{i=1}^{n} [\frac{y_i}{h_\theta(x_i)}-\frac{1-y_i}{1-h_\theta(x_i)}]\cdot[h_\theta(x_i)]^{‘}_{z} \cdot z^{‘}_\theta\\<br>    &amp;=\sum_{i=1}^{n}[\frac{y_i}{h_\theta(x_i)}-\frac{1-y_i}{1-h_\theta(x_i)}] \cdot h_\theta(x_i)[1-h_\theta(x_i)] \cdot z^{‘}_\theta \\<br>    &amp;=\sum_{i=1}^{n}[y_i-h_\theta(x_i)] \cdot x_i<br>    \end{split}<br>\tag{4}<br>$$</p><p><font face="宋体" size="2">* 注：sigmoid求导结果<br>$$<br>f’\left(x \right)=f\left(x \right)\left[1-f\left(x \right) \right]<br>$$ </font></p><p>&lt;\font&gt;<br>对公式4进行迭代，可求得参数$\theta$。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="对偏置项b的处理"><a href="#对偏置项b的处理" class="headerlink" title="对偏置项b的处理"></a>对偏置项b的处理</h3><p>&emsp;&emsp;在大部分资料中，会在输入$x$和权重$\theta$中增加一列常数列作为偏置项，这样做的好处是不需要对其进行单独处理，可随权重$\theta$一起求解，下面来讨论一下单独求解偏置项$b$的步骤。</p><p>&emsp;&emsp;假设输入为$[x_1,x_2,…,x_n]$，权重为$[\theta_1,\theta_2,…,\theta_n]$，偏置项为$[b_1,b_2,…,b_n]$，则公式2变为<br>$$<br>    h_{\theta}\left(x \right)=\frac{1}{1+e^{-z}}=\frac{1}{1+e^{-\theta ^{T}x-b}}<br>$$<br>接下来需让公示3对变量b求导<br>$$<br>\begin{split}<br>    l^{‘}(b)&amp;=\sum_{i=1}^{n} [\frac{y_i}{h_\theta(x_i)}-\frac{1-y_i}{1-h_\theta(x_i)}] \cdot h^{‘}_\theta(x_i)\\<br>    &amp;=\sum_{i=1}^{n} [\frac{y_i}{h_\theta(x_i)}-\frac{1-y_i}{1-h_\theta(x_i)}] \cdot [h_\theta(x_i)]^{‘}_{z} \cdot z^{‘}_b\\<br>    &amp;=\sum_{i=1}^{n}[\frac{y_i}{h_\theta(x_i)}-\frac{1-y_i}{1-h_\theta(x_i)}] \cdot h_\theta(x_i)[1-h_\theta(x_i)] \cdot z^{‘}_b \\<br>    &amp;=\sum_{i=1}^{n}[y_i-h_\theta(x_i)] \cdot x_i<br>    \end{split}<br>\tag{5}<br>$$<br>对公式5进行迭代，可求得参数$b$。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>&emsp;&emsp;为了加深对公示的理解，代码没有直接使用tensorflow内置的优化器，手动实现了逻辑回归梯度下降。示例如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="built_in">import</span> tensorflow as tf</span><br><span class="line">from sklearn <span class="built_in">import</span> datasets</span><br><span class="line"><span class="built_in">import</span> numpy as np</span><br><span class="line">from sklearn.preprocessing <span class="built_in">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line"><span class="attr">iris</span> = datasets.load_iris()</span><br><span class="line"><span class="attr">data_x</span> = np.array(iris['data'])</span><br><span class="line"><span class="attr">data_y</span> = np.array(iris['target']).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">print data_x.shape</span><br><span class="line">print data_y.shape</span><br><span class="line"><span class="attr">enc</span> = OneHotEncoder()</span><br><span class="line">enc.fit(data_y)</span><br><span class="line"><span class="comment"># 多分类问题，对label进行one-hot编码</span></span><br><span class="line"><span class="attr">targets</span> = enc.transform(data_y).toarray()</span><br><span class="line"><span class="comment"># 输入行数不指定，列数为特征个数</span></span><br><span class="line"><span class="attr">X</span> = tf.placeholder(<span class="attr">dtype=tf.float32,</span> <span class="attr">shape=(None,</span> data_x.shape[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># 输出行数不指定，列数类别个数</span></span><br><span class="line"><span class="attr">y</span> = tf.placeholder(<span class="attr">dtype=tf.float32,</span> <span class="attr">shape=(None,</span> <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line"><span class="attr">alpha</span> = <span class="number">0.0001</span></span><br><span class="line"><span class="comment"># 迭代次数</span></span><br><span class="line"><span class="attr">epoch</span> = <span class="number">500</span></span><br><span class="line"><span class="comment"># 权重</span></span><br><span class="line"><span class="attr">theta</span> = tf.Variable(tf.random_uniform([data_x.shape[<span class="number">1</span>], <span class="number">3</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>), <span class="attr">name='theta')</span></span><br><span class="line"><span class="comment"># 偏置</span></span><br><span class="line"><span class="attr">b</span> = tf.Variable(tf.random_uniform([<span class="number">3</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>), <span class="attr">name='b')</span></span><br><span class="line"><span class="comment"># 预测值</span></span><br><span class="line"><span class="attr">predict_y</span> = tf.nn.softmax(tf.matmul(X, theta) + b)</span><br><span class="line"><span class="comment"># 误差</span></span><br><span class="line"><span class="attr">error</span> = tf.cast(y, tf.float32) - predict_y</span><br><span class="line"><span class="comment"># 代价函数，使用交叉熵函数，手动实现</span></span><br><span class="line"><span class="attr">cost</span> = tf.reduce_mean(-tf.reduce_sum(y * tf.log(predict_y), <span class="attr">reduction_indices=1))</span></span><br><span class="line"><span class="comment"># 权重的负梯度</span></span><br><span class="line"><span class="attr">theta_gradient</span> = -tf.matmul(tf.matrix_transpose(X), error, <span class="attr">name='theta_gradient')</span></span><br><span class="line"><span class="comment"># 偏置的负梯度</span></span><br><span class="line"><span class="attr">b_gradient</span> = - tf.reduce_mean(tf.matmul(tf.transpose(X), error), <span class="attr">reduction_indices=0,</span> <span class="attr">name='b_gradient')</span></span><br><span class="line"><span class="comment"># 权重迭代项</span></span><br><span class="line"><span class="attr">training_op1</span> = tf.assign(theta, theta - alpha * theta_gradient)</span><br><span class="line"><span class="comment"># 偏置迭代项</span></span><br><span class="line"><span class="attr">training_op2</span> = tf.assign(b, b - alpha * b_gradient)</span><br><span class="line"><span class="comment"># 全局初始化</span></span><br><span class="line"><span class="attr">init</span> = tf.global_variables_initializer()</span><br><span class="line"><span class="keyword">with</span> tf.Session() as sess:</span><br><span class="line">    init.run()</span><br><span class="line">    for i <span class="keyword">in</span> range(epoch):</span><br><span class="line">        sess.run([training_op1, training_op2, cost], <span class="attr">feed_dict=&#123;X:</span> data_x, y: targets&#125;)</span><br><span class="line">        print sess.run(theta, <span class="attr">feed_dict=&#123;X:</span> data_x, y: targets&#125;)</span><br><span class="line">        print sess.run(b, <span class="attr">feed_dict=&#123;X:</span> data_x, y: targets&#125;)</span><br><span class="line">        print sess.run(cost, <span class="attr">feed_dict=&#123;X:</span> data_x, y: targets&#125;)</span><br></pre></td></tr></table></figure><p>代码详见<a href="https://github.com/yajian/machine_learning/blob/master/logistic_regression/lr_model.py" target="_blank" rel="noopener">逻辑回归代码</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/wc781708249/article/details/79290523" target="_blank" rel="noopener">Tensorflow实现梯度下降各种方法</a></li><li>机器学习实战-基于Scikit-Learn和Tensorflow，机械工业出版社</li><li>机器学习实战，人民邮电出版社</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;机器学习主要解决两类问题：回归和分类，上篇文章中的线性回归模型是回归模型的一种，但并不能用于分类问题，本文将介绍一种可以用于分类问题的回归算法–logistic回归。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;利用logistic回归进行分类的主要思想是
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yajian.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="回归" scheme="http://yajian.github.io/tags/%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>线性回归</title>
    <link href="http://yajian.github.io/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yajian.github.io/线性回归/</id>
    <published>2018-11-27T13:07:43.000Z</published>
    <updated>2018-12-20T03:44:32.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;说到回归一般都指线性回归，回归的目的是预测数值型的目标值。线性回归模型的优点在于结果易于理解，计算简单，缺点在于对非线性的数据拟合不好。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;线性回归就是对输入特征加权求和，在加上偏置项进行预测。公式如下所示：</p><p>$$<br>                    \widehat{h}=\theta_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}<br>                    \tag{1}<br>$$</p><p>其中，$\widehat{h}$代表预测值，$n$是特征的个数，${x_i}$代表第i个特征值，$\theta_{i}$ 代表第i个特征的权重，将上式向量化有</p><p>$$<br>                            \widehat{h}=h_{\theta}(X)=X\theta<br>                            \tag{2}<br>$$</p><p>其中$\theta$是模型的参数向量，X是实例的特征向量，$h_{\theta}$是使用模型参数$\theta$做参数的假设函数。</p><font face="宋体" size="2">* 注：这里为什么写成$X\theta$的形式，而不是$\theta X$呢？在实际使用中，实例的特征是行向量，由多个实例构成输入矩阵，而权重是列向量，其具体形式如下<br>    $$<br>    X\theta=<br>     \begin{bmatrix}<br>      x_0^1 &amp; x_0^2 &amp; … &amp;x_0^n \\<br>      x_1^1 &amp; x_1^2 &amp; … &amp;x_1^n \\<br>      …  &amp; … &amp; … &amp;… \\<br>      x_m^1 &amp; x_m^1 &amp; … &amp;x_m^1<br>      \end{bmatrix}<br>      \begin{bmatrix}<br>      \theta_0  \\<br>      \theta_1  \\<br>      …   \\<br>      \theta_n<br>      \end{bmatrix}<br>    $$<br></font><p>&emsp;&emsp;为了衡量模型效果，一般使用MSE(均方误差，Mean Square Error)描述线性回归的预测值和真实值之间的偏差。假设输入的样本特征为$x_1,x_2,…,x_n$，对应的样本值为$y_1,y_2,y_3,…,y_n$，则MSE的定义为</p><p>$$<br>J(\theta)=\frac{1}{2}(\widehat{y}_i-y_i)^2=\frac{1}{2}\sum^n_{i=1}(h_{\theta}(x_i)-y_i)^2<br>\tag{3}<br>$$<br>写成向量形式有<br>$$<br>J(\theta)=\frac{1}{2}(X\theta-Y)^2<br>\tag{4}<br>$$<br>&emsp;&emsp;以上就是线性回归的基本公式和损失函数。</p><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><p>&emsp;&emsp;我们的目标是找到合适的一组权重$\theta$让$J(\theta)$最小，这样就说明我们的模型越符合实际效果越好。一般有两种方式进行求解，直接求解和梯度下降。</p><h2 id="解析求解"><a href="#解析求解" class="headerlink" title="解析求解"></a>解析求解</h2><p>&emsp;&emsp;我们已经拿到了损失函数的表达形式，可以从公式$(4)$中直接推到出$\theta$，过程如下。</p><p>$$<br>\begin{split}<br>    J(\theta)=\frac{1}{2}(X\theta-Y)^2&amp;=\frac{1}{2}(X\theta-Y)^T(X\theta-Y)\\<br>    &amp;=\frac{1}{2}(\theta^TX^T-Y^T)(X\theta-Y)\\<br>    &amp;=\frac{1}{2}(\theta^TX^TX\theta-\theta^TX^TY-Y^TX\theta-Y^TY)<br>\end{split}<br>\tag{5}<br>$$<br>&emsp;&emsp;接下来对$J(\theta)$求偏导</p><p>$$<br>\begin{split}<br>    \frac{\partial^{2}J(\theta)}{\partial\theta^{2}}&amp;=\frac{1}{2}(2 \cdot X^TX\theta-2 \cdot X^TY)\\<br>    &amp;=X^TX\theta-X^TY<br>\end{split}<br>\tag{6}<br>$$</p><font face="宋体" size="2">* 注：这里用到了几个矩阵求导公式<br>$$\frac{dAB}{dB}=A^T$$<br>$$\frac{dA^TB}{dA}=B$$<br>$$\frac{dX^TAX}{dX}=(A+A^T)X$$<br></font><p>&emsp;&emsp;令导数为0，有</p><p>$$\frac{\partial^{2}J(\theta)}{\partial\theta^{2}}=0$$</p><p>$$X^TX\theta-X^TY=0$$</p><p>$$X^TX\theta=X^TY$$</p><p>$$\theta=(X^TX)^{-1}X^TY \tag{7}$$</p><p>&emsp;&emsp;最终推到出$(7)$，直接求解需要用到实例数据$X$及对应的预测值$Y$，在输入不大的情况下可以快速求得权重矩阵。但$(7)$中含有矩阵求逆运算，其算法复杂度通常在$O(n^2.4)$到$O(n^3)$之间，在高维大数据量的情况下直接求解的计算量很大；而且对于某些损失函数是凸函数的模型($X^TX$不可逆)来说，无法求得损失函数的偏导，该方法失效，只能使用梯度下降算法。</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>&emsp;&emsp;梯度下降是一种通用的优化算法，梯度下降的中心思想就是迭代地调整参数从而使成本函数最小化。</p><font face="宋体" size="2">* 注：梯度下降的形象解释：<br>假设你迷失在山上的迷雾中，你能感受到的只有脚下地面的坡度。快速到达山脚的一个策略就是沿着最陡的方向下坡。这就是梯度下降的做法：通过测量参数向量$\theta$相关的误差函数的局部梯度，并不断沿着梯度的方向调整，直到梯度降为0，到达最小值。<br></font><p>&emsp;&emsp;具体来说，首先使用一个随机的$\theta$值，即随机初始化，然后逐步改进，每次踏出一步，每一步都尝试降低成本函数，直到算法收敛到一个最小值。梯度下降中一个重要的参数是每一步的步长，该参数被称为学习率。如果学习率太低，算法需要经过大量迭代才能收敛，如果太高，有可能越过最小值甚至比上一步迭代的结果还大，导致模型无法收敛。</p><p>&emsp;&emsp;对于线性回归，梯度下降的数学表达形式如下。假设第$i$次迭代的权重为$\theta_i$，学习率为$\eta$，第$i+1$次迭代的权重为<br>$$<br>    \theta_{i+1}=\theta_i-\eta \cdot \frac{\partial^2J(\theta)}{\partial\theta^2}<br>    \tag{8}<br>$$</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>&emsp;&emsp;下面使用tensorflow实现两种求解方式，以加州房价预测数据为例。</p><h2 id="tensorflow实现解析求解"><a href="#tensorflow实现解析求解" class="headerlink" title="tensorflow实现解析求解"></a>tensorflow实现解析求解</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from sklearn.datasets import fetch_california_housing</span><br><span class="line"></span><br><span class="line">n_epochs = 10000  <span class="comment"># 把样本集数据学习1000次</span></span><br><span class="line">learning_rate = 0.01  <span class="comment"># 步长 学习率 不能太大 太大容易来回震荡 太小 耗时间，跳不出局部最优解</span></span><br><span class="line"><span class="comment"># 可以写learn_rate动态变化，随着迭代次数越来越大 ，学习率越来越小 learning_rate/n_epoches</span></span><br><span class="line">housing = fetch_california_housing()</span><br><span class="line">m, n = housing.data.shape</span><br><span class="line">housing_data_plus_bias = np.c_[np.ones((m, 1)), housing.data]</span><br><span class="line">housing_data_target = housing.target.reshape(-1, 1)</span><br><span class="line">X = tf.constant(housing_data_plus_bias, tf.float32)</span><br><span class="line">y = tf.constant(housing_data_target, tf.float32)</span><br><span class="line">XT = tf.transpose(X)</span><br><span class="line">theta = tf.matmul(tf.matmul(tf.matrix_inverse(tf.matmul(XT, X)), XT), y)</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    theta_value = theta.eval()</span><br><span class="line">    print theta_value</span><br></pre></td></tr></table></figure><h2 id="tensorflow实现梯度下降"><a href="#tensorflow实现梯度下降" class="headerlink" title="tensorflow实现梯度下降"></a>tensorflow实现梯度下降</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.datasets import fetch_california_housing</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"></span><br><span class="line">n_epochs = 10000  <span class="comment"># 把样本集数据学习1000次</span></span><br><span class="line">learning_rate = 0.01  <span class="comment"># 步长 学习率 不能太大 太大容易来回震荡 太小 耗时间，跳不出局部最优解</span></span><br><span class="line"><span class="comment"># 可以写learn_rate动态变化，随着迭代次数越来越大 ，学习率越来越小 learning_rate/n_epoches</span></span><br><span class="line">housing = fetch_california_housing()</span><br><span class="line">m, n = housing.data.shape</span><br><span class="line">housing_data_plus_bias = np.c_[np.ones((m, 1)), housing.data]</span><br><span class="line"><span class="comment"># 可以使用TensorFlow或者Numpy或者sklearn的StandardScaler去进行归一化</span></span><br><span class="line"><span class="comment"># 归一化可以最快的找到最优解</span></span><br><span class="line"><span class="comment"># 常用的归一化方式：</span></span><br><span class="line"><span class="comment"># 最大最小值归一化 (x-min)/(max-min)</span></span><br><span class="line"><span class="comment"># 方差归一化 x/方差</span></span><br><span class="line"><span class="comment"># 均值归一化 x-均值 结果有正有负 可以使调整时的速度越来越快。</span></span><br><span class="line">scaler = StandardScaler().fit(housing_data_plus_bias)  <span class="comment"># 创建一个归一化对象</span></span><br><span class="line">scaled_housing_data_plus_bias = scaler.transform(housing_data_plus_bias)  <span class="comment"># 真正执行 因为来源于sklearn所以会直接执行，不会延迟。</span></span><br><span class="line">housing_data_target = housing.target.reshape(-1, 1)</span><br><span class="line"></span><br><span class="line">X = tf.placeholder(tf.float32, name='X')</span><br><span class="line">y = tf.placeholder(tf.float32, name='y')</span><br><span class="line"></span><br><span class="line"><span class="comment"># random_uniform函数创建图里一个节点包含随机数值，给定它的形状和取值范围，就像numpy里面rand()函数</span></span><br><span class="line">theta = tf.Variable(tf.random_uniform([n + 1, 1], -1.0, 1.0), name='theta')  <span class="comment">#参数\theta，列向量，按照-1.0到1.0随机给</span></span><br><span class="line">y_pred = tf.matmul(X, theta, name=<span class="string">"predictions"</span>)  <span class="comment"># 相乘 m行一列</span></span><br><span class="line">error = y_pred - y  <span class="comment"># 列向量和列向量相减 是一组数</span></span><br><span class="line">mse = tf.reduce_mean(tf.square(error), name=<span class="string">"mse"</span>)  <span class="comment"># 误差平方加和，公式（3）的手动实现</span></span><br><span class="line">gradients = 2.0 / m * tf.matmul(tf.transpose(X), error)  <span class="comment"># 梯度公式</span></span><br><span class="line">training_op = tf.assign(theta, theta - learning_rate * gradients)  <span class="comment"># 即公式(8)，需对该式进行迭代</span></span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(init)  <span class="comment"># 初始化</span></span><br><span class="line"></span><br><span class="line">    for epoch in range(n_epochs):  <span class="comment"># 迭代1000次</span></span><br><span class="line">        if epoch % 100 == 0:</span><br><span class="line">            print(<span class="string">"Epoch"</span>, epoch, <span class="string">"MSE = "</span>,</span><br><span class="line">                  sess.run(mse, feed_dict=&#123;X: scaled_housing_data_plus_bias, y: housing_data_target&#125;))  <span class="comment"># 每运行100次的时候输出</span></span><br><span class="line">        sess.run(training_op, feed_dict=&#123;X: scaled_housing_data_plus_bias, y: housing_data_target&#125;)</span><br><span class="line"></span><br><span class="line">    best_theta = theta.eval()  <span class="comment"># 最后的w参数值</span></span><br><span class="line">    print(best_theta)</span><br></pre></td></tr></table></figure><p>以上代码详见<a href="https://github.com/yajian/machine_learning/tree/master/linear_regression" target="_blank" rel="noopener">线性回归tensorflow实现</a></p><p>#参考</p><ol><li><a href="https://www.cnblogs.com/LHWorldBlog/p/8658044.html" target="_blank" rel="noopener">【TensorFlow篇】–Tensorflow框架初始，实现机器学习中多元线性回归</a></li><li>机器学习实战-基于Scikit-Learn和Tensorflow，机械工业出版社</li><li>机器学习实战，人民邮电出版社</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;说到回归一般都指线性回归，回归的目的是预测数值型的目标值。线性回归模型的优点在于结果易于理解，计算简单，缺点在于对非
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yajian.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="回归" scheme="http://yajian.github.io/tags/%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>storm系列3:Topology创建过程</title>
    <link href="http://yajian.github.io/storm%E7%B3%BB%E5%88%973-Topology%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yajian.github.io/storm系列3-Topology创建过程/</id>
    <published>2018-08-22T08:16:48.000Z</published>
    <updated>2018-08-22T08:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Topology创建过程"><a href="#Topology创建过程" class="headerlink" title="Topology创建过程"></a>Topology创建过程</h1><p>&emsp;&emsp;Topology是storm的一个完整工作流，由spout、bolt等组件构成。下面我们来看一下Topology是如何被创建的。</p><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>&emsp;&emsp;我们一般会在storm的入口函数调用TopologyBuilder进行Topology的创建，如下所示</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TopologyBuilder</span> builder = <span class="function"><span class="keyword">new</span> <span class="title">TopologyBuilder</span>();</span></span><br><span class="line"><span class="function"><span class="comment">//设置spout</span></span></span><br><span class="line"><span class="function"><span class="title">builder</span>.<span class="title">setSpout</span>(<span class="type">SENTENCE_SPOUT_ID</span>, spout, <span class="number">2</span>);</span></span><br><span class="line"><span class="function"><span class="comment">//设置bolt</span></span></span><br><span class="line"><span class="function"><span class="title">builder</span>.<span class="title">setBolt</span>(<span class="type">SPLIT_BOLT_ID</span>, splitBolt, <span class="number">2</span>).<span class="title">setNumTasks</span>(<span class="number">4</span>).<span class="title">shuffleGrouping</span>(<span class="type">SENTENCE_SPOUT_ID</span>);</span></span><br><span class="line"><span class="function"><span class="title">builder</span>.<span class="title">setBolt</span>(<span class="type">COUNT_BOLT_ID</span>, countBolt, <span class="number">4</span>).<span class="title">fieldsGrouping</span>(<span class="type">SPLIT_BOLT_ID</span>, new <span class="type">Fields</span>("word"));</span></span><br><span class="line"><span class="function"><span class="title">builder</span>.<span class="title">setBolt</span>(<span class="type">REPORT_BOLT_ID</span>, reportBolt).<span class="title">globalGrouping</span>(<span class="type">COUNT_BOLT_ID</span>);</span></span><br></pre></td></tr></table></figure><h2 id="TopolgyBuilder"><a href="#TopolgyBuilder" class="headerlink" title="TopolgyBuilder"></a>TopolgyBuilder</h2><p>&emsp;&emsp;比较重要的实例变量</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有提交的bolt放入_bolts中</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, IRichBolt&gt; _bolts = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//所有提交的spout放入_spouts中</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, IRichSpout&gt; _spouts = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//所有topology的spout和bolt放入_commons中</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, ComponentCommon&gt; _commons = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="setSpout"><a href="#setSpout" class="headerlink" title="setSpout"></a>setSpout</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public SpoutDeclarer setSpout(String <span class="keyword">id</span>, IRichSpout spout, Number parallelism_hint) throws IllegalArgumentException &#123;</span><br><span class="line">    <span class="comment">//检测输入id是不是唯一的，主要是从实例变量的map里看有没有对应的key存在</span></span><br><span class="line">    validateUnusedId(<span class="keyword">id</span>);</span><br><span class="line">    <span class="comment">//构建ComponentCommon对象并进行初始化，最后放入_commons中</span></span><br><span class="line">    initCommon(<span class="keyword">id</span>, spout, parallelism_hint);</span><br><span class="line">    <span class="comment">//放入_spouts中</span></span><br><span class="line">    _spouts.put(<span class="keyword">id</span>, spout);</span><br><span class="line">    <span class="keyword">return</span> new SpoutGetter(<span class="keyword">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initCommon"><a href="#initCommon" class="headerlink" title="initCommon"></a>initCommon</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> initCommon(String id, IComponent component, Number parallelism) throws IllegalArgumentException &#123;</span><br><span class="line">       ComponentCommon <span class="keyword">common</span> = <span class="keyword">new</span> ComponentCommon();</span><br><span class="line"><span class="comment">//设置消息流来源和分组方式</span></span><br><span class="line">       <span class="keyword">common</span>.set_inputs(<span class="keyword">new</span> HashMap&lt;GlobalStreamId, Grouping&gt;());</span><br><span class="line"><span class="comment">//设置并行度</span></span><br><span class="line">       <span class="keyword">if</span>(parallelism!=<span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> dop = parallelism.intValue();</span><br><span class="line">           <span class="keyword">if</span>(dop &lt; <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parallelism must be positive."</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">common</span>.set_parallelism_hint(dop);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//设置组件的配置参数</span></span><br><span class="line">       Map conf = component.getComponentConfiguration();</span><br><span class="line">       <span class="keyword">if</span>(conf!=<span class="keyword">null</span>) <span class="keyword">common</span>.set_json_conf(JSONValue.toJSONString(conf));</span><br><span class="line">       _commons.put(id, <span class="keyword">common</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="setBolt"><a href="#setBolt" class="headerlink" title="setBolt"></a>setBolt</h3><p>&emsp;&emsp;与setSpout类似</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public BoltDeclarer setBolt(String <span class="built_in">id</span>, IRichBolt bolt, Number parallelism_hint) throws IllegalArgumentException &#123;</span><br><span class="line">    validateUnusedId(<span class="built_in">id</span>);</span><br><span class="line">    initCommon(<span class="built_in">id</span>, bolt, parallelism_hint);</span><br><span class="line">    _bolts.<span class="keyword">put</span>(<span class="built_in">id</span>, bolt);</span><br><span class="line"><span class="built_in">    return</span> new BoltGetter(<span class="built_in">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> setSpout和setBolt区别 </strong> </p><p>看上去二者完成的事情基本类似，但是返回值有区别</p><p>SpoutGetter的源码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SpoutGetter</span> <span class="keyword">extends</span> <span class="title">ConfigGetter&lt;SpoutDeclarer&gt;</span> <span class="title">implements</span> <span class="title">SpoutDeclarer</span> </span>&#123;</span><br><span class="line">    public <span class="type">SpoutGetter</span>(<span class="type">String</span> id) &#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而BoltGetter源码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected <span class="class"><span class="keyword">class</span> <span class="title">BoltGetter</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">ConfigGetter</span></span>&lt;<span class="title">BoltDeclarer</span>&gt; <span class="keyword"><span class="keyword">implements</span> <span class="type">BoltDeclarer</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> _boltId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BoltGetter(<span class="keyword">String</span> boltId) &#123;</span><br><span class="line">        <span class="keyword">super</span>(boltId);</span><br><span class="line">        _boltId = boltId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BoltDeclarer fieldsGrouping(<span class="keyword">String</span> componentId, Fields fields) &#123;</span><br><span class="line">        <span class="keyword">return</span> fieldsGrouping(componentId, Utils.DEFAULT_STREAM_ID, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BoltDeclarer fieldsGrouping(<span class="keyword">String</span> componentId, <span class="keyword">String</span> streamId, Fields fields) &#123;</span><br><span class="line">        <span class="keyword">return</span> grouping(componentId, streamId, Grouping.fields(fields.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BoltDeclarer globalGrouping(<span class="keyword">String</span> componentId) &#123;</span><br><span class="line">        <span class="keyword">return</span> globalGrouping(componentId, Utils.DEFAULT_STREAM_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BoltDeclarer globalGrouping(<span class="keyword">String</span> componentId, <span class="keyword">String</span> streamId) &#123;</span><br><span class="line">        <span class="keyword">return</span> grouping(componentId, streamId, Grouping.fields(<span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BoltDeclarer shuffleGrouping(<span class="keyword">String</span> componentId) &#123;</span><br><span class="line">        <span class="keyword">return</span> shuffleGrouping(componentId, Utils.DEFAULT_STREAM_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BoltDeclarer shuffleGrouping(<span class="keyword">String</span> componentId, <span class="keyword">String</span> streamId) &#123;</span><br><span class="line">        <span class="keyword">return</span> grouping(componentId, streamId, Grouping.shuffle(<span class="keyword">new</span> <span class="type">NullStruct</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现BoltGetter还实现了不同的分组方式，如</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> BoltDeclarer grouping(<span class="keyword">String</span> componentId, <span class="keyword">String</span> streamId, Grouping grouping) &#123;</span><br><span class="line">    _commons.<span class="keyword">get</span>(_boltId).put_to_inputs(<span class="keyword">new</span> <span class="type">GlobalStreamId</span>(componentId, streamId), grouping);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分组的本质是在_common中通过对应的boltId找到对应的ComponentCommon对象，对inputs属性进行设置。</p><h3 id="createTopology"><a href="#createTopology" class="headerlink" title="createTopology()"></a>createTopology()</h3><p>&emsp;&emsp;TopologyBuilder中还有一个比较重要的方法–createTopology()，其主要完成最后的封装工作。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">public</span> StormTopology createTopology() &#123;</span><br><span class="line"><span class="comment">//bolt集合</span></span><br><span class="line">       Map&lt;<span class="keyword">String</span>, Bolt&gt; boltSpecs = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//spout集合</span></span><br><span class="line">       Map&lt;<span class="keyword">String</span>, SpoutSpec&gt; spoutSpecs = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">       maybeAddCheckpointSpout();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">String</span> boltId: <span class="type">_bolts</span>.keySet()) &#123;</span><br><span class="line">    <span class="comment">//通过boltId获取Bolt</span></span><br><span class="line">           IRichBolt bolt = _bolts.<span class="keyword">get</span>(boltId);</span><br><span class="line">           bolt = maybeAddCheckpointTupleForwarder(bolt);</span><br><span class="line">    <span class="comment">//设置对应ComponentCommon对象的streams属性(输出的字段列表是否为直接流)</span></span><br><span class="line">           ComponentCommon common = getComponentCommon(boltId, bolt);</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               maybeAddCheckpointInputs(common);</span><br><span class="line"><span class="comment">//把bolt和common一起放入bolt集合</span></span><br><span class="line">               boltSpecs.put(boltId, <span class="keyword">new</span> <span class="type">Bolt</span>(ComponentObject.serialized_java(Utils.javaSerialize(bolt)), common));</span><br><span class="line">           &#125;<span class="keyword">catch</span>(RuntimeException wrapperCause)&#123;</span><br><span class="line">               <span class="keyword">if</span> (wrapperCause.getCause() != <span class="literal">null</span> &amp;&amp; NotSerializableException.class.equals(wrapperCause.getCause().getClass()))&#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(</span><br><span class="line">                       <span class="string">"Bolt '"</span> + boltId + <span class="string">"' contains a non-serializable field of type "</span> + wrapperCause.getCause().getMessage() + <span class="string">", "</span> +</span><br><span class="line">                       <span class="string">"which was instantiated prior to topology creation. "</span> + wrapperCause.getCause().getMessage() + <span class="string">" "</span> +</span><br><span class="line">                       <span class="string">"should be instantiated within the prepare method of '"</span> + boltId + <span class="string">" at the earliest."</span>, wrapperCause);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> wrapperCause;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//对spout的处理和bolt的处理基本一致</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">String</span> spoutId: <span class="type">_spouts</span>.keySet()) &#123;</span><br><span class="line">           IRichSpout spout = _spouts.<span class="keyword">get</span>(spoutId);</span><br><span class="line">           ComponentCommon common = getComponentCommon(spoutId, spout);</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               spoutSpecs.put(spoutId, <span class="keyword">new</span> <span class="type">SpoutSpec</span>(ComponentObject.serialized_java(Utils.javaSerialize(spout)), common));</span><br><span class="line">           &#125;<span class="keyword">catch</span>(RuntimeException wrapperCause)&#123;</span><br><span class="line">               <span class="keyword">if</span> (wrapperCause.getCause() != <span class="literal">null</span> &amp;&amp; NotSerializableException.class.equals(wrapperCause.getCause().getClass()))&#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(</span><br><span class="line">                       <span class="string">"Spout '"</span> + spoutId + <span class="string">"' contains a non-serializable field of type "</span> + wrapperCause.getCause().getMessage() + <span class="string">", "</span> +</span><br><span class="line">                       <span class="string">"which was instantiated prior to topology creation. "</span> + wrapperCause.getCause().getMessage() + <span class="string">" "</span> +</span><br><span class="line">                       <span class="string">"should be instantiated within the prepare method of '"</span> + spoutId + <span class="string">" at the earliest."</span>, wrapperCause);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> wrapperCause;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       StormTopology stormTopology = <span class="keyword">new</span> <span class="type">StormTopology</span>(spoutSpecs,</span><br><span class="line">               boltSpecs,</span><br><span class="line">               <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="keyword">String</span>, StateSpoutSpec&gt;());</span><br><span class="line"></span><br><span class="line">       stormTopology.set_worker_hooks(_workerHooks);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Utils.addVersions(stormTopology);</span><br></pre></td></tr></table></figure><p>最终我们设置的bolt和spout都被封装到了StormTopology中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;总的来讲TopologyBuilder就是根据分组方式把spout和bolt节点连接起来形成一个拓扑结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Topology创建过程&quot;&gt;&lt;a href=&quot;#Topology创建过程&quot; class=&quot;headerlink&quot; title=&quot;Topology创建过程&quot;&gt;&lt;/a&gt;Topology创建过程&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Topology是storm的一个完
      
    
    </summary>
    
      <category term="storm" scheme="http://yajian.github.io/categories/storm/"/>
    
    
      <category term="storm" scheme="http://yajian.github.io/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>storm系列2:并行度和资源分配</title>
    <link href="http://yajian.github.io/storm%E7%B3%BB%E5%88%972-%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%92%8C%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D/"/>
    <id>http://yajian.github.io/storm系列2-并行度和资源分配/</id>
    <published>2018-08-22T07:02:19.000Z</published>
    <updated>2018-08-22T08:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并行度相关概念"><a href="#并行度相关概念" class="headerlink" title="并行度相关概念"></a>并行度相关概念</h1><p>&emsp;&emsp;和spark driver、work、executor一样，storm也有一套自己的概念。Storm集群中的节点可以分为两类：主节点nimbus，从节点supervisor。nimbus主要负责分配计算资源，supervisor主要负责执行client提交的任务。supervisor节点在运行任务时，涉及到以下三个概念：worker、executor、task。</p><h2 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h2><p>&emsp;&emsp;supervisor在执行任务时，会启动一个或者多个jvm进程，这些进程统称为worker。默认情况下一个supervisor最多可以启动4个worker，也可以通过修改storm.yaml参数进行修改。因为topology最终都是通过worker来执行的，所以nimbus并不关心有几个supervisor，只关心有多少个worker，至于worker分配在哪个节点上，nimbus是不关心的。需要说明的是，一个worker只能同时运行一个topology，如果在该worker运行时又有topology提交，nimbus会将其分配给其他空闲的worker。</p><h2 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h2><p>&emsp;&emsp;在一个jvm进程中，有时候我们会开启多个线程执行任务，这里executor的概念就是线程的概念。</p><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>&emsp;&emsp;executor中运行的topology的一个component，如spout、bolt，叫做task，task是storm中进行计算的最小运行单位，表示spout和bolt的运行实例。</p><h1 id="资源设置的注意事项"><a href="#资源设置的注意事项" class="headerlink" title="资源设置的注意事项"></a>资源设置的注意事项</h1><h2 id="worker-1"><a href="#worker-1" class="headerlink" title="worker"></a>worker</h2><p>&emsp;&emsp;worker个数的增加，会导致worker之间数据传输时间增加。如果程序瓶颈在于待处理的元组数据太多算力不足，那么通过可以通过增加worker个数提高计算效率。</p><h2 id="executor-1"><a href="#executor-1" class="headerlink" title="executor"></a>executor</h2><p>&emsp;&emsp;executor是真正的并行度。executor初始数量=spout数量+bolt数量+acker数量，也就是task个数，默认一个executor对应一个task。其中spout、bolt、acker数量运行时是不会变化的，但是executor数量是可以变化的。</p><h2 id="task-1"><a href="#task-1" class="headerlink" title="task"></a>task</h2><p>&emsp;&emsp;task的存在是为了topology扩展的灵活性，与并行度无关。task在实际执行数据处理。如果单纯提高task个数，不增加executor个数，并不一定能提高性能。提高task任务数量，可以为后期进行弹性计算（rebalance）即后期动态调整某一组件的并行度。</p><h1 id="并行度计算"><a href="#并行度计算" class="headerlink" title="并行度计算"></a>并行度计算</h1><p>计算并行度官网有个比较好的例子</p><div align="center"><br><img src="/storm系列2-并行度和资源分配/并行度计算.jpg" width="400" height="300" title="并行度计算"><br></div><p>上图中，有2个worker进程，</p><ul><li>蓝色的BlueSpout有2个executor进程，每个executor有1个task，并行度为2；</li><li>绿色的GreenBolt有2个executor进程，每个executor有2个task，并行度为2；</li><li>黄色的YellowBolt有6个executor进程，每个executor有1个task，并行度为6；</li><li>上图总平行度是2+2+6=10，具体分配到每个worker上就是5个</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并行度相关概念&quot;&gt;&lt;a href=&quot;#并行度相关概念&quot; class=&quot;headerlink&quot; title=&quot;并行度相关概念&quot;&gt;&lt;/a&gt;并行度相关概念&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;和spark driver、work、executor一样，storm也有一
      
    
    </summary>
    
      <category term="storm" scheme="http://yajian.github.io/categories/storm/"/>
    
    
      <category term="storm" scheme="http://yajian.github.io/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://yajian.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yajian.github.io/设计模式-状态模式/</id>
    <published>2018-08-18T09:12:26.000Z</published>
    <updated>2018-08-18T09:28:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>&emsp;&emsp;很多情况下，一个对象的行为取决于一个或多个状态变化的属性，这样的属性叫状态。这样的对象叫做有状态的对象，这样的状态是从事先定义好的一系列值中获取的。当一个这样的对象与外部产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生改变。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="环境类"><a href="#环境类" class="headerlink" title="环境类"></a>环境类</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Context &#123;</span><br><span class="line">    private State <span class="keyword">state</span>;</span><br><span class="line"></span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        return <span class="keyword">state</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="built_in">set</span>State(State <span class="keyword">state</span>) &#123;</span><br><span class="line">        this.<span class="keyword">state</span> = <span class="keyword">state</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象状态接口"><a href="#抽象状态接口" class="headerlink" title="抽象状态接口"></a>抽象状态接口</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>State &#123;</span><br><span class="line"></span><br><span class="line">    void handle(Context context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体状态类"><a href="#具体状态类" class="headerlink" title="具体状态类"></a>具体状态类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"player is in start state"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"start state"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"player is in stop state"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"stop state"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line">    <span class="built_in">Context</span> <span class="built_in">context</span> = new <span class="built_in">Context</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    StartState startState = new StartState()<span class="comment">;</span></span><br><span class="line">    startState.handle(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    StopState stopState = new StopState()<span class="comment">;</span></span><br><span class="line">    stopState.handle(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">player is <span class="keyword">in</span> start <span class="keyword">state</span></span><br><span class="line">player is <span class="keyword">in</span> stop <span class="keyword">state</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;状态模式和命令模式一样，可以用于消除if-else等条件选择语句。</p><ul><li>优点</li></ul><p>&emsp;&emsp;封装了状态转换规则，状态转换代码可以封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务代码中。</p><p>&emsp;&emsp;将所有与状态有关的行为放到一个类中，只需要注入不同的状态对象即可是环境对象拥有不同的行为。</p><p>&emsp;&emsp;允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来讲业务方法和状态转换代码交织在一起。</p><ul><li>缺点</li></ul><p>&emsp;&emsp;增加系统内类的个数。<br>&emsp;&emsp;实现复杂，增加系统设计难度<br>&emsp;&emsp;对“开闭原则”支持不好，增加新的状态类需要修改负责状态转换的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;状态模式&quot;&gt;&lt;a href=&quot;#状态模式&quot; class=&quot;headerlink&quot; title=&quot;状态模式&quot;&gt;&lt;/a&gt;状态模式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;很多情况下，一个对象的行为取决于一个或多个状态变化的属性，这样的属性叫状态。这样的对象叫做有状态的对
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yajian.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yajian.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-命令模式</title>
    <link href="http://yajian.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yajian.github.io/设计模式-命令模式/</id>
    <published>2018-08-18T03:57:07.000Z</published>
    <updated>2018-08-18T04:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>&emsp;&emsp;在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个。我们只需在程序运行时指定具体的请求接收者即可，此时可以使用命令模式来进行设计，使得请求发送者和接受者之间消除耦合，让对象的调用关系更加灵活。</p><p>&emsp;&emsp;命令模式可以对发送者和接受者完全解耦，发送者和接受者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的动机。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="命令的执行者"><a href="#命令的执行者" class="headerlink" title="命令的执行者"></a>命令的执行者</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Light</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"灯打开了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"灯关了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象命令接口"><a href="#抽象命令接口" class="headerlink" title="抽象命令接口"></a>抽象命令接口</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>Command &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体命令实现类"><a href="#具体命令实现类" class="headerlink" title="具体命令实现类"></a>具体命令实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用者类"><a href="#调用者类" class="headerlink" title="调用者类"></a>调用者类</h2><p>这里假设为遥控器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buttonOnPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> void test() &#123;</span><br><span class="line">        Controller controller = <span class="keyword">new</span> <span class="type">Controller</span>();</span><br><span class="line">        Light light = <span class="keyword">new</span> <span class="type">Light</span>();</span><br><span class="line">        LightOffCommand lightOffCommand = <span class="keyword">new</span> <span class="type">LightOffCommand</span>(light);</span><br><span class="line">        LightOnCommand lightOnCommand = <span class="keyword">new</span> <span class="type">LightOnCommand</span>(light);</span><br><span class="line"></span><br><span class="line">        controller.setCommand(lightOffCommand);</span><br><span class="line">        controller.buttonOnPressed();</span><br><span class="line">        controller.setCommand(lightOnCommand);</span><br><span class="line">        controller.buttonOnPressed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">灯关了</span></span><br><span class="line"><span class="comment">灯打开了</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>命令模式的好处在于可以将命令的请求这和命令的执行者进行解耦，但是在复杂场景下，命令类会变得很多，不方便进行管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerlink&quot; title=&quot;命令模式&quot;&gt;&lt;/a&gt;命令模式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yajian.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yajian.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>storm系列1:storm集群搭建</title>
    <link href="http://yajian.github.io/storm%E7%B3%BB%E5%88%971-storm%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yajian.github.io/storm系列1-storm集群搭建/</id>
    <published>2018-08-16T09:17:14.000Z</published>
    <updated>2018-08-16T10:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近在研究流式特征处理，所以搭建了storm集群环境，把过程发出来，以备后续查看。</p><h1 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h1><ul><li><p>jdk: oracle官网下载的jdk1.8.0_181版本</p></li><li><p>zookeeper: zookeeper下载的zookeeper-3.4.12版本</p></li><li><p>storm： storm下载的apache-storm-1.2.2版本</p></li></ul><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$HOME/.local/bin:$HOME/bin</span><br><span class="line"><span class="attribute">JAVA_HOME</span>=/home/user/jdk1.8.0_181</span><br><span class="line"><span class="attribute">JRE_HOME</span>=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="attribute">STORM_HOME</span>=/home/user/apache-storm-1.2.2</span><br><span class="line"><span class="attribute">CLASSPATH</span>=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="attribute">ZOOKEEPER_HOME</span>=/home/user/zookeeper-3.4.12</span><br><span class="line"><span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$JAVA_HOME/bin:$STORM_HOME/bin:$ZOOKEEPER_HOME/bin</span><br><span class="line"><span class="builtin-name">export</span> PATH</span><br><span class="line"><span class="builtin-name">export</span> JAVA_HOME</span><br><span class="line"><span class="builtin-name">export</span> JRE_HOME</span><br><span class="line"><span class="builtin-name">export</span> CLASSPATH</span><br><span class="line"><span class="builtin-name">export</span> ZOOKEEPER_HOME</span><br><span class="line"><span class="builtin-name">export</span> STORM_HOME</span><br></pre></td></tr></table></figure><h1 id="配置zookeeper"><a href="#配置zookeeper" class="headerlink" title="配置zookeeper"></a>配置zookeeper</h1><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>&emsp;&emsp;zookeeper需要修改ZOOKEEPER_HOME/conf/zoo.cfg文件，加入下列信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">tickTime</span>=2000</span><br><span class="line"><span class="attribute">dataDir</span>=/var/zookeeper/</span><br><span class="line"><span class="attribute">clientPort</span>=2181</span><br><span class="line"><span class="attribute">initLimit</span>=5</span><br><span class="line"><span class="attribute">syncLimit</span>=2</span><br><span class="line">server.<span class="attribute">1</span>=m7-pce-hdp01:2888:3888 </span><br><span class="line">server.<span class="attribute">2</span>=m7-pce-hdp02:2888:3888 </span><br><span class="line">server.<span class="attribute">3</span>=m7-pce-hdp03:2888:3888</span><br></pre></td></tr></table></figure><p>其中dataDir是zookeeper的数据文件目录；server.id=host:port:port，其中id是每个节点的编号，这个编号需要在dataDir目录下创建myid文件中写入，m7-pce-hdp01~m7-pce-hdp03是hostname，第一个port用于连接leader的端口，第二个port用于连接leader的选举端口。</p><h2 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h2><p>执行ZOOKEEPER_HOME/bin/zkServer.sh启动zookeeper，并执行zkServer.sh status，查看是否启动成功</p><h1 id="配置storm"><a href="#配置storm" class="headerlink" title="配置storm"></a>配置storm</h1><p>&emsp;&emsp;storm配置文件在STORM_HOME/conf/storm.yaml，需要配置一下几个信息</p><h2 id="配置zookeeper列表"><a href="#配置zookeeper列表" class="headerlink" title="配置zookeeper列表"></a>配置zookeeper列表</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">storm.zookeeper.servers:</span><br><span class="line">    -<span class="ruby"> <span class="string">"m7-pce-hdp01"</span></span></span><br><span class="line"><span class="ruby">    - <span class="string">"m7-pce-hdp02"</span></span></span><br><span class="line"><span class="ruby">    - <span class="string">"m7-pce-hdp03"</span></span></span><br></pre></td></tr></table></figure><h2 id="配置nimbus"><a href="#配置nimbus" class="headerlink" title="配置nimbus"></a>配置nimbus</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nimbus<span class="selector-class">.seeds</span>: [<span class="string">"m7-pce-hdp01"</span>]</span><br></pre></td></tr></table></figure><h2 id="配置storm本地dir"><a href="#配置storm本地dir" class="headerlink" title="配置storm本地dir"></a>配置storm本地dir</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">storm<span class="selector-class">.local</span><span class="selector-class">.dir</span>: <span class="string">"/home/user/apache-storm-1.2.2/workdir"</span></span><br></pre></td></tr></table></figure><h2 id="配置supervisor-slots-ports"><a href="#配置supervisor-slots-ports" class="headerlink" title="配置supervisor.slots.ports"></a>配置supervisor.slots.ports</h2><p> supervisor.slots.ports是指每个机器可以启动多少个worker，一个端口号代表一个worker</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">supervisor.slots.ports:</span><br><span class="line">     -<span class="ruby"> <span class="number">6700</span></span></span><br><span class="line"><span class="ruby">     - <span class="number">6701</span></span></span><br><span class="line"><span class="ruby">     - <span class="number">6702</span></span></span><br><span class="line"><span class="ruby">     - <span class="number">6703</span></span></span><br></pre></td></tr></table></figure><h1 id="启动Storm集群"><a href="#启动Storm集群" class="headerlink" title="启动Storm集群"></a>启动Storm集群</h1><h2 id="启动nimbus集群"><a href="#启动nimbus集群" class="headerlink" title="启动nimbus集群"></a>启动nimbus集群</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nohup storm nimbus <span class="meta">&amp;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用jps查看后台线程会发现多了nimbus（先显示config value，配置正确后变成nimbus）</p><h2 id="启动supervisor"><a href="#启动supervisor" class="headerlink" title="启动supervisor"></a>启动supervisor</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nohup storm supervisor <span class="meta">&amp;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用jps查看后台线程出现Supervisor</p><h2 id="启动监控ui"><a href="#启动监控ui" class="headerlink" title="启动监控ui"></a>启动监控ui</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nohup storm ui <span class="meta">&amp;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用jps查看后台线程出现core</p><p>在浏览器中输入“<a href="http://m7-pce-hdp01:8080/index.html”即可看到" target="_blank" rel="noopener">http://m7-pce-hdp01:8080/index.html”即可看到</a></p><h1 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h1><p>&emsp;&emsp;集群配置完，我们开始向集群提交任务。</p><h2 id="配置本地storm"><a href="#配置本地storm" class="headerlink" title="配置本地storm"></a>配置本地storm</h2><p>&emsp;&emsp;需要在storm.yaml文件中配置nimbus</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nimbus<span class="selector-class">.host</span>: <span class="string">"m7-pce-hdp01"</span></span><br></pre></td></tr></table></figure><h2 id="准备程序"><a href="#准备程序" class="headerlink" title="准备程序"></a>准备程序</h2><p>&emsp;&emsp;在STORM_HOME/examples下有很多示例代码，我们选用storm-starter进行测试。这里需要用maven进行打包，执行mvn package就行。然后我们就能在target文件夹下找到storm-starter-1.2.2.jar，一会就提交它。</p><h2 id="提交任务-1"><a href="#提交任务-1" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">storm jar storm-starter<span class="number">-1.2</span><span class="number">.2</span>.jar storm/starter/StatefulTopology wordcountexample</span><br></pre></td></tr></table></figure><p>然后输入storm list</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2703 [main] INFO  o.a.s.u.NimbusClient - Found leader nimbus : m7-pce-hdp01:6627</span><br><span class="line">Topology<span class="emphasis">_name        Status     Num_</span>tasks  Num<span class="emphasis">_workers  Uptime_</span>secs</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">wordcountexample     ACTIVE     7          1            183702</span><br></pre></td></tr></table></figure><p>也可以进入ui页面进行查看运行状态。storm任务运行完也不会停止，需要手动kill。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;以上就是storm集群的搭建过程，很简单，基本上没遇到什么问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近在研究流式特征处理，所以搭建了storm集群环境，把过程发出来，以备后续查看。&lt;/p&gt;
&lt;h1 id=&quot;安装包准备&quot;&gt;&lt;a href=&quot;#安装包准备&quot; class=&quot;headerlink&quot; title=&quot;安装包准备&quot;&gt;&lt;/a&gt;安装包准备&lt;/h1&gt;
      
    
    </summary>
    
      <category term="storm" scheme="http://yajian.github.io/categories/storm/"/>
    
    
      <category term="storm" scheme="http://yajian.github.io/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="http://yajian.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yajian.github.io/设计模式-代理模式/</id>
    <published>2018-08-13T04:16:21.000Z</published>
    <updated>2018-08-13T04:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>&emsp;&emsp;代理模式是属于结构模式之一。该模式的作用主要是为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接使用另一个对象，此时代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>&emsp;&emsp;代理模式的实现方式有静态代理、jdk动态代理和cglib动态代理。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>&emsp;&emsp;静态代理是指在程序运行前代理类的.class文件就已经存在，是由程序员在编码时手动实现的。</p><p>&emsp;&emsp;示例如下：</p><p>定义一个接口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Person &#123;</span><br><span class="line"></span><br><span class="line">    void speak();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是actor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Actor actor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">(Actor actor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actor = actor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入代理"</span>);</span><br><span class="line">        actor.speak();</span><br><span class="line">        System.out.println(<span class="string">"退出代理"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Actor actor = <span class="keyword">new</span> <span class="type">Actor</span>();</span><br><span class="line">        Agent agent = <span class="keyword">new</span> <span class="type">Agent</span>(actor);</span><br><span class="line">        agent.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">进入代理</span></span><br><span class="line"><span class="comment">这是actor</span></span><br><span class="line"><span class="comment">退出代理</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>&emsp;&emsp;jdk动态代理与静态代理最大的区别就是代理类的.class文件是在运行时生成的，而且被代理类必须要实现一个接口。</p><p>&emsp;&emsp;示例如下，接口和被代理类和静态代理一样</p><p>代理类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="title">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Actor actor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JdkProxy(Actor actor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.actor = actor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"进入代理"</span>);</span><br><span class="line">        method.invoke(actor, args);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"退出代理"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object getProxy() &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="keyword">this</span>.actor.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Actor actor = <span class="keyword">new</span> <span class="type">Actor</span>();</span><br><span class="line">        JdkProxy jdkProxy = <span class="keyword">new</span> <span class="type">JdkProxy</span>(actor);</span><br><span class="line">        Person proxy = (Person) jdkProxy.getProxy();</span><br><span class="line">        proxy.speak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进入代理</span></span><br><span class="line"><span class="comment">这是actor</span></span><br><span class="line"><span class="comment">退出代理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><p>&emsp;&emsp;cglib是一个功能强大的代码生成包，其底层依赖asm框架。cglib实现动态代理最大的特点就是被代理类不需要实现接口。</p><p>&emsp;&emsp;示例如下</p><p>被代理类</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActorNoInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"我是actor没有实现接口"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object actor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span><span class="params">(ActorNoInterface actor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actor = actor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入cglib代理"</span>);</span><br><span class="line">        methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"退出cglib代理"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.actor.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> enhancer.<span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        CglibProxy cglibProxy = <span class="keyword">new</span> <span class="type">CglibProxy</span>(<span class="keyword">new</span> <span class="type">ActorNoInterface</span>());</span><br><span class="line">        ActorNoInterface actor = (ActorNoInterface) cglibProxy.getInstance();</span><br><span class="line">        actor.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;代理模式是属于结构模式之一。该模式的作用主要是为其他对象提供一种代理以控制对这个对象的访问。在某些情
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yajian.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yajian.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring-ioc</title>
    <link href="http://yajian.github.io/spring-ioc/"/>
    <id>http://yajian.github.io/spring-ioc/</id>
    <published>2018-08-06T02:27:15.000Z</published>
    <updated>2018-12-14T10:27:37.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sprint-ioc容器"><a href="#sprint-ioc容器" class="headerlink" title="sprint ioc容器"></a>sprint ioc容器</h1><p>&emsp;&emsp;在spring中，最基本的IOC容器接口就是BeanFactory，这个接口为具体的IOC容器实现提供了基本功能的规定。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface BeanFactory &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里是对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，  </span></span><br><span class="line">    <span class="comment">//如果需要得到工厂本身，需要转义         </span></span><br><span class="line">    <span class="keyword">String</span> FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里根据bean的名字，在IOC容器中得到bean实例，这个IOC容器就是一个大的抽象工厂。  </span></span><br><span class="line">    <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name) <span class="keyword">throws</span> BeansException;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里根据bean的名字和Class类型来得到bean实例，和上面的方法不同在于它会抛出异常：如果根据名字取得的bean实例的Class类型和需要的不同的话。  </span></span><br><span class="line">    <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name, Class requiredType) <span class="keyword">throws</span> BeansException;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里提供对bean的检索，看看是否在IOC容器有这个名字的bean  </span></span><br><span class="line">    <span class="built_in">boolean</span> containsBean(<span class="keyword">String</span> name);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里根据bean名字得到bean实例，并同时判断这个bean是不是单例  </span></span><br><span class="line">    <span class="built_in">boolean</span> isSingleton(<span class="keyword">String</span> name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里对得到bean实例的Class类型  </span></span><br><span class="line">    Class getType(<span class="keyword">String</span> name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里得到bean的别名，如果根据别名检索，那么其原名也会被检索出来  </span></span><br><span class="line">    <span class="keyword">String</span>[] getAliases(<span class="keyword">String</span> name);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;BeanFactory里只对IOC容器的基本行为做了定义，对bean的如何定义及其加载过程并不关心。就像我们只关心我们得到什么产品的对象，至于工厂是怎么产生这些对象的，这个接口并不关心。</p><h2 id="Spring-IOC初始化过程"><a href="#Spring-IOC初始化过程" class="headerlink" title="Spring IOC初始化过程"></a>Spring IOC初始化过程</h2><p>&emsp;&emsp;spring ioc初始化顺序主要是：读取xml资源、解析xml资源、注册到BeanFactory。完成初始化过程后，bean就在BeanFactory中等待调用。下面以ClassPathXmlApplicationContext入口类为例，详细说明初始化过程。</p><h3 id="从传入配置到创建BeanFactory"><a href="#从传入配置到创建BeanFactory" class="headerlink" title="从传入配置到创建BeanFactory"></a>从传入配置到创建BeanFactory</h3><p>首先入口处在ClassPathXmlApplicationContext类中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> ClassPathXmlApplicationContext(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line"><span class="comment">//就是从这里开始进行初始化</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refresh方法在父类AbstractApplicationContext中，它具体的实现是这样的</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">//准备工作，记录容器启动的时间、标记启动状态</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这步完成创建BeanFactory、加载bean、注册bean的过程</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置BeanFactory的类加载器</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里完成所有singleton bean的初始化</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"><span class="comment">//广播时间，applicationContext初始化完成</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来去obtainFreshBeanFactory方法中看看进行了什么操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//主要逻辑，完成创建BeanFactory及Bean的加载和注册</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再去AbstractRefreshableApplicationContext类中看看refreshBeanFactory方法做了哪些操作</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//如果已经加载过BeanFactory，那么销毁所有bean，并关闭BeanFactory</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里创建了一个BeanFactory，createBeanFactory就是返回一个DefaultListableBeanFactory实例</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line"><span class="comment">//设置是否允许覆盖，是否允许循环引用</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">//这里把bean加载到BeanFactory中，后面具体分析</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bean的加载及注册"><a href="#bean的加载及注册" class="headerlink" title="bean的加载及注册"></a>bean的加载及注册</h2><p>loadBeanDefinitions方法在AbstractRefreshableApplicationContext中是个抽象方法，其实现在子类AbstractXmlApplicationContext类中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//创建一个XmlBeanDefinitionReader</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//初始化该reader，主要是给子类覆盖用</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"><span class="comment">//这里会加载bean</span></span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadBeanDefinitions方法主体在XmlBeanDefinitionReader中</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span>(<span class="params">EncodedResource encodedResource</span>) throws BeanDefinitionStoreException</span> &#123;</span><br><span class="line">Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">get</span>();</span><br><span class="line"><span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">set</span>(currentResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!currentResources.<span class="keyword">add</span>(encodedResource)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心部分</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">currentResources.<span class="keyword">remove</span>(encodedResource);</span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">remove</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中DefaultBeanDefinitionDocumentReader类承担了大部分xml标签解析的功能，解析的细节就不具体展开了。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span>(<span class="params">Element ele, BeanDefinitionParserDelegate <span class="keyword">delegate</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">//delegate.parseBeanDefinitionElement方法会去解析各个节点，最后生成BeanDefinition,由于bean有name和alias属性，所以这里定义了BeanDefinitionHolder来存储BeanDefinition</span></span><br><span class="line">BeanDefinitionHolder bdHolder = <span class="keyword">delegate</span>.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">bdHolder = <span class="keyword">delegate</span>.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里完成注册</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerBeanDefinition方法</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">public</span> static void registerBeanDefinition(</span><br><span class="line"><span class="keyword">BeanDefinitionHolder </span>definitionHolder, <span class="keyword">BeanDefinitionRegistry </span>registry)</span><br><span class="line">throws <span class="keyword">BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">String </span><span class="keyword">beanName </span>= definitionHolder.getBeanName()<span class="comment">;</span></span><br><span class="line">//注册</span><br><span class="line">registry.registerBeanDefinition(<span class="keyword">beanName, </span>definitionHolder.getBeanDefinition())<span class="comment">;</span></span><br><span class="line">//有别名的话，根据别名注册一遍</span><br><span class="line"><span class="keyword">String[] </span>aliases = definitionHolder.getAliases()<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (aliases != null) &#123;</span><br><span class="line">//这里没有存<span class="meta">alias</span>-&gt;<span class="keyword">beanDefinition，而是存储beanName-&gt;alias</span></span><br><span class="line"><span class="keyword"></span>for (<span class="keyword">String </span><span class="meta">alias</span> : aliases) &#123;</span><br><span class="line">registry.registerAlias(<span class="keyword">beanName, </span><span class="meta">alias</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerBeanDefinition方法主体位于DefaultListableBeanFactory中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.<span class="keyword">get</span>(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//若不允许覆盖，则报错</span></span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用框架定义的bean还是用于定义的bean</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用新bean覆盖旧bean</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a different definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with an equivalent definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//判断是否有其他Bean开始初始化</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">synchronized (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//最正常的是进入到这里，注册过程就是把beanName和beanDefinition放入map中</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截止到这里，已经初始化了Bean容器，<bean></bean>配置也转化成了BeanDefinition，并注册在了BeanFactory。</p><h2 id="初始化singleton-bean"><a href="#初始化singleton-bean" class="headerlink" title="初始化singleton bean"></a>初始化singleton bean</h2><p>&emsp;&emsp;在上面提到的refersh方法中，有一个finishBeanFactoryInitialization方法，完成初始化所有单例的bean</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">protected</span> void finishBeanFactoryInitialization(ConfigurableListableBeanFactory <span class="keyword">beanFactory) </span>&#123;</span><br><span class="line">//初始化名为conversionService的<span class="keyword">Bean</span></span><br><span class="line"><span class="keyword"></span><span class="meta">if</span> (<span class="keyword">beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) </span>&amp;&amp;</span><br><span class="line"><span class="keyword">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, </span>ConversionService.class)) &#123;</span><br><span class="line"><span class="keyword">beanFactory.setConversionService(</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, </span>ConversionService.class))<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化LoadTimeWeaverAware类型的<span class="keyword">Bean，一般用于织入第三方模块，在class文件加载JVM的时候动态织入</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">String[] </span>weaverAwareNames = <span class="keyword">beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, </span>false, false)<span class="comment">;</span></span><br><span class="line">for (<span class="keyword">String </span>weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">beanFactory.setTempClassLoader(null);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beanFactory.freezeConfiguration();</span></span><br><span class="line"><span class="keyword"></span>//这里初始化其他<span class="keyword">bean</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beanFactory.preInstantiateSingletons();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>继续到DefaultListableBeanFactory类中看看preInstantiateSingletons方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"><span class="comment">//触发所有non-lazy的singleton bean的初始化操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">String</span> beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">//合并父bean中的配置，即&lt;bean parent=""&gt;</span></span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">//非抽象、非懒加载、单例</span></span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="comment">//判断是不是FactoryBean，是的话在beanName前加上&amp;符号</span></span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="built_in">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="built_in">Boolean</span>&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">Boolean</span> run() &#123;</span><br><span class="line"><span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line"><span class="comment">//普通bean初始化的地方</span></span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">String</span> beanName : beanNames) &#123;</span><br><span class="line"><span class="built_in">Object</span> singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="built_in">Object</span>&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">Object</span> run() &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBean(String name)方法完成普通bean的初始化，该方法是从BeanFactory中获取bean的方法，但是初始化过程也封装在这个方法中</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getBean(<span class="keyword">String</span> name) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getBean是用来从容器中获取bean的，这里先看有没有初始化，没有的话先初始化，完成初始化直接返回</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T doGetBean(</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> <span class="keyword">Object</span>[] args, <span class="built_in">boolean</span> typeCheckOnly)</span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">//获取beanname，如果是factoryBean前面加个&amp;</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> beanName = transformedBeanName(name);</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">Object</span> bean;</span><br><span class="line"><span class="comment">//检查是否已经创建过了</span></span><br><span class="line"><span class="keyword">Object</span> sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是普通bean返回sharedInstance，如果是factoryBean返回它创建的那个实例对象</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查beanDefinition是否存在</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">//如果不存在，看看父容器中是否存在</span></span><br><span class="line"><span class="keyword">String</span> nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里要开始创建bean了，对于singleton bean来说，容器中没有创建过该bean</span></span><br><span class="line"><span class="comment">//对于prototype的bean来说，本身就要创建一个新bean</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"><span class="comment">//先初始化所有依赖的bean</span></span><br><span class="line"><span class="keyword">String</span>[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">String</span> dependsOnBean : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dependsOnBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dependsOnBean + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册依赖关系</span></span><br><span class="line">registerDependentBean(dependsOnBean, beanName);</span><br><span class="line"><span class="comment">//初始化被依赖的bean</span></span><br><span class="line">getBean(dependsOnBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建singleton实例</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;<span class="keyword">Object</span>&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里是主要逻辑！！</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是prototype的</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line"><span class="keyword">Object</span> prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">String</span> scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.<span class="built_in">get</span>(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">Object</span> scopedInstance = scope.<span class="built_in">get</span>(beanName, <span class="keyword">new</span> ObjectFactory&lt;<span class="keyword">Object</span>&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line"><span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查类型对不对，对的话就返回了</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type ["</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是创建bean，我们来到了AbstractAutowrieCapableBeanFactory类，这个类和Autowire注解有关</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> createBean(<span class="keyword">String</span> beanName, RootBeanDefinition mbd, <span class="keyword">Object</span>[] args) <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"><span class="comment">//确保BeanDefinition中的class被加载</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="keyword">Object</span> bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里创建bean</span></span><br><span class="line"><span class="keyword">Object</span> beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看doCreateBean方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> doCreateBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="keyword">Object</span>[] args) &#123;</span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//这里完成实例化</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个就是bean实例</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">Object</span> bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="built_in">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;<span class="keyword">Object</span>&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getObject() <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Object</span> exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里负责装配属性</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//处理bean初始化完之后的回调</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">Object</span> earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line"><span class="keyword">String</span>[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;<span class="keyword">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;<span class="keyword">String</span>&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.<span class="built_in">add</span>(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里为止，完成了整个初始化流程。上面的过程里，最重要的三个函数是创建bean实例的方法createBeanInstance，一个是依赖注入的populateBean方法，还有回调方法initializeBean。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function">BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//确保加载了class</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="comment">//校验访问权限</span></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line"><span class="comment">//采用工厂方法实例化</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">instantiateUsingFactoryMethod</span><span class="params">(beanName, mbd, args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不是第一次创建，我们可以通过第一次创建知道采用无参构造函数还是构造函数依赖注入来完成实例化</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">autowireConstructor</span><span class="params">(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">instantiateBean</span><span class="params">(beanName, mbd)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断用有参构造函数</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="comment">//构造函数依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">autowireConstructor</span><span class="params">(beanName, mbd, ctors, args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">instantiateBean</span><span class="params">(beanName, mbd)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入无参构造函数方法看看</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BeanWrapper instantiateBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">Object</span> beanInstance;</span><br><span class="line"><span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="keyword">Object</span>&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> run() &#123;</span><br><span class="line"><span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果不存在方法覆盖，那就是用java反射进行实例化，否则使用CGLIB</span></span><br><span class="line"><span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">constructorToUse =clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法实例化</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> BeanUtils.<span class="title">instantiateClass</span><span class="params">(constructorToUse)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">instantiateWithMethodInjection</span><span class="params">(bd, beanName, owner)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性注入</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">protected</span> void <span class="keyword">populateBean(String </span><span class="keyword">beanName, </span>RootBeanDefinition mbd, <span class="keyword">BeanWrapper </span><span class="keyword">bw) </span>&#123;</span><br><span class="line">//<span class="keyword">bean实例的所有属性</span></span><br><span class="line"><span class="keyword"></span>PropertyValues pvs = mbd.getPropertyValues()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">if</span> (<span class="keyword">bw </span>== null) &#123;</span><br><span class="line"><span class="meta">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">throw new <span class="keyword">BeanCreationException(</span></span><br><span class="line"><span class="keyword"></span>mbd.getResourceDescription(), <span class="keyword">beanName, </span><span class="string">"Cannot apply property values to null instance"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">else</span> &#123;</span><br><span class="line">// Skip property <span class="keyword">population </span>phase for null instance.</span><br><span class="line">return<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//到这步<span class="keyword">bean实例化完成，但是还没开始属性设值</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">boolean </span>continueWithPropertyPopulation = true<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">for (<span class="keyword">BeanPostProcessor </span><span class="keyword">bp </span>: getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="meta">if</span> (<span class="keyword">bp </span>instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) <span class="keyword">bp;</span></span><br><span class="line"><span class="keyword"></span><span class="meta">if</span> (!ibp.postProcessAfterInstantiation(<span class="keyword">bw.getWrappedInstance(), </span><span class="keyword">beanName)) </span>&#123;</span><br><span class="line">continueWithPropertyPopulation = false<span class="comment">;</span></span><br><span class="line"><span class="keyword">break;</span></span><br><span class="line"><span class="keyword"></span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">return<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME <span class="title">||</span></span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = new MutablePropertyValues(pvs)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// <span class="keyword">Add </span>property values <span class="keyword">based </span>on autowire <span class="keyword">by </span>name <span class="meta">if</span> applicable.</span><br><span class="line"><span class="meta">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">//通过名字找到属性</span><br><span class="line">autowireByName(<span class="keyword">beanName, </span>mbd, <span class="keyword">bw, </span>newPvs)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">Add </span>property values <span class="keyword">based </span>on autowire <span class="keyword">by </span>type <span class="meta">if</span> applicable.</span><br><span class="line"><span class="meta">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">//通过类型进行装配</span><br><span class="line">autowireByType(<span class="keyword">beanName, </span>mbd, <span class="keyword">bw, </span>newPvs)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pvs = newPvs<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean </span>hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors()<span class="comment">;</span></span><br><span class="line"><span class="keyword">boolean </span>needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">if</span> (hasInstAwareBpps <span class="title">||</span> needsDepCheck) &#123;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(<span class="keyword">bw, </span>mbd.allowCaching)<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">for (<span class="keyword">BeanPostProcessor </span><span class="keyword">bp </span>: getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="meta">if</span> (<span class="keyword">bp </span>instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) <span class="keyword">bp;</span></span><br><span class="line"><span class="keyword"></span>pvs = ibp.postProcessPropertyValues(pvs, filteredPds, <span class="keyword">bw.getWrappedInstance(), </span><span class="keyword">beanName);</span></span><br><span class="line"><span class="keyword"></span><span class="meta">if</span> (pvs == null) &#123;</span><br><span class="line">return<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">if</span> (needsDepCheck) &#123;</span><br><span class="line">checkDependencies(<span class="keyword">beanName, </span>mbd, filteredPds, pvs)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置实例的属性值</span><br><span class="line">applyPropertyValues(<span class="keyword">beanName, </span>mbd, <span class="keyword">bw, </span>pvs)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理回调</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> initializeBean(<span class="keyword">final</span> <span class="keyword">String</span> beanName, <span class="keyword">final</span> <span class="keyword">Object</span> bean, RootBeanDefinition mbd) &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="keyword">Object</span>&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> run() &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Object</span> wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//处理bean定义中的init-method</span></span><br><span class="line"><span class="comment">//或者bean实现了InitializingBean接口，调用afterPropertiesSet方法</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sprint-ioc容器&quot;&gt;&lt;a href=&quot;#sprint-ioc容器&quot; class=&quot;headerlink&quot; title=&quot;sprint ioc容器&quot;&gt;&lt;/a&gt;sprint ioc容器&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在spring中，最基本的IOC容器
      
    
    </summary>
    
      <category term="java" scheme="http://yajian.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://yajian.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://yajian.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yajian.github.io/设计模式-工厂模式/</id>
    <published>2018-08-06T02:25:44.000Z</published>
    <updated>2018-08-06T02:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>&emsp;&emsp;工厂模式是常见的5中创建型设计模式之一，主要用于新建对象场景。首先我们要明确为什么要使用工厂模式，在程序中new一个对象然后使用是最基本的需求，但是如果该对象发生一些改变或者派生出新对象，势必需要修改原代码，这样做破坏了开放封闭原则。所以我们希望又一个专门的类来产生我们要用的对象，使用时直接跟它请求需要的对象就好了，这样即使对象产生过程发生变化使用对象的类也不需要进行修改。其实可以认为new一个类是一种硬编码。这个时候工厂模式就能帮我们解决这个问题。工厂模式又细分为简单工厂、工厂方法和抽象工厂，下面我们来详细解释三种模式的结构。</p><h2 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h2><p>&emsp;&emsp;话说有一位土豪想有一辆车，最直接的办法就是自己造，Benz奔驰、Bmw宝马、Audi奥迪，自己动手丰衣足食。但是自己造太麻烦还累，土豪有钱，费那个劲干啥，可以直接去工厂买啊。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Bmw</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">         ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;于是土豪来到了三个工厂考察。</p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>&emsp;&emsp;土豪来到了第一家小工厂，他想要的Benz、BMW、Audi都有，土豪很满意。我们看这个工厂是怎么生产汽车的。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CarFactory&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car getCar(String <span class="class"><span class="keyword">type</span>) <span class="title">throws</span> <span class="title">Exception</span>&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span>.<span class="title">equals</span></span>(<span class="string">"Benz"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span>.<span class="title">equals</span></span>(<span class="string">"Audi"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="class"><span class="keyword">type</span>.<span class="title">equals</span></span>(<span class="string">"Bmw"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Bmw();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            throw <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;土豪转念一想，这仨车太low，老子要布加迪，你能生产么。工厂领导傻眼了，他们工厂只能生产这三种车，要想生产其他的还要升级生产线。土豪一听，那我还是看看其他的工厂吧。</p><p>&emsp;&emsp;简单工厂实现方式很简单，但是一但产品类型增加该方法又面临着修改，产品类型较多的时候逻辑复杂度会增加，不利于系统维护，依然不符合开闭原则。</p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>&emsp;&emsp;于是土豪来到了第二家工厂，这家工厂很大，总工厂下面有小工厂，生产线也是标准化的，能根据土豪的需要增加生产线，布加迪不是梦，土豪很满意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"> <span class="function">Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BmwFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;土豪很满意，但是又想了想平时需要开一辆商务车，撩妹子需要一辆跑车，让这个工厂单开一条生产线生产跑车再提车妹子都跑了，于是摇摇头继续考察第三家工厂。<br>&emsp;&emsp;使用时创建一个具体的工厂，然后调用createCar方法即可。这种实现方式的缺点是没增加一种新车型，需要新建一个对应的factory类。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>&emsp;&emsp;土豪来到了第三家工厂，这家工厂把车按品牌分类，每个品牌包括商务车和跑车，于是它旗下的商务车工厂专门生产各种品牌的商务车，跑车工厂专门生产各个品牌的跑车。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AudioCar</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BWMCar</span></span>&#123;</span><br><span class="line">          ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioBusinessCar</span> <span class="keyword">implements</span> <span class="title">AudioCar</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioSportCar</span> <span class="keyword">implements</span> <span class="title">AudioCar</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWBusinessCar</span> <span class="keyword">implements</span> <span class="title">BMWCar</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWSportCar</span> <span class="keyword">implements</span> <span class="title">BMWCar</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line"><span class="function">AudioCar <span class="title">createAudioCar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BMWCar <span class="title">createBMWCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> AudioCar <span class="title">createAudioCar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AudioBudinessCar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BMWCar <span class="title">createBMWCar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BMWBudinessCar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SportCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> AudioCar <span class="title">createAudioCar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AudioSportCar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BMWCar <span class="title">createBMWCar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BMWSportCar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;土豪一看很满意，直接提了两辆车回家。</p><p>&emsp;&emsp;这种方式比较适合新增产品族，比如工厂扩大生产想生产轿车，直接增加一个轿车工厂就好了。但是如果新增产品，比如增加Benz车的跑车和商务车，那基本需要对所有类进行修改。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>抽象工厂和工厂方法模式最大的区别在于工厂方法针对的是一个产品等级结构，而抽象工厂需要面对多个产品等级结构。</li><li>当抽象工厂中只存在一个产品等级结构，抽象工厂退化成工厂方法模式</li><li>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建对象，并将创建对象的方法设置为静态方法时，工厂方法退化成简单工厂模式。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;工厂模式是常见的5中创建型设计模式之一，主要用于新建对象场景。首先我们要明确为什么要使用工厂模式，在
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yajian.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yajian.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-如何防止单例模式被破坏</title>
    <link href="http://yajian.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%A2%AB%E7%A0%B4%E5%9D%8F/"/>
    <id>http://yajian.github.io/设计模式-如何防止单例模式被破坏/</id>
    <published>2018-07-26T11:53:17.000Z</published>
    <updated>2018-08-06T02:31:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式是否安全"><a href="#单例模式是否安全" class="headerlink" title="单例模式是否安全"></a>单例模式是否安全</h1><p>&emsp;&emsp;在<a href="https://yajian.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式-单例模式</a>这篇博客介绍了单例模式的几种实现方式，但是按照上述方式是否能够保证一定是单例呢？答案是否定的，如果不加限制，通过反射和序列化可以破坏单例模式。</p><h1 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>&emsp;&emsp;单例模式把类的构造方法设置为private访问级别，导致外部类无法新建对象，通过反射我们可以修改访问级别，从外部新建单例类对象。以饿汉模式为例</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class StarveSingleton &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> StarveSingleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>StarveSingleton();</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> StarveSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> StarveSingleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> void main(String[] args) &#123;</span><br><span class="line">//输出true</span><br><span class="line">System.out.println(StarveSingleton.getInstance() == StarveSingleton.getInstance());</span><br><span class="line">        Class clazz = StarveSingleton.class;</span><br><span class="line">        Constructor<span class="keyword"> constructor</span>= clazz.getDeclaredConstructor(null);</span><br><span class="line">       <span class="keyword"> constructor</span>.setAccessible(true);</span><br><span class="line">        StarveSingleton<span class="built_in"> instance </span>= (StarveSingleton)<span class="keyword"> constructor</span>.newInstance(null);</span><br><span class="line">//输出false</span><br><span class="line">        System.out.println(instance == StarveSingleton.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从结果来看，通过反射的方式，单例模式被破坏，我们可以随意产生新的单例类实例。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>&emsp;&emsp;如果单例类继承了serializable接口，那么序列化也可以破坏单例模式。依然以饿汉模式为例</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class StarveSingleton implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> StarveSingleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>StarveSingleton();</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> StarveSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> StarveSingleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream outputStream =<span class="built_in"> new </span>ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream =<span class="built_in"> new </span>ObjectOutputStream(outputStream);</span><br><span class="line">        StarveSingleton starveSingleton = StarveSingleton.getInstance();</span><br><span class="line">        objectOutputStream.writeObject(starveSingleton);</span><br><span class="line"></span><br><span class="line">        byte[] bytes = outputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream inputStream =<span class="built_in"> new </span>ObjectInputStream(new ByteArrayInputStream(bytes));</span><br><span class="line">        StarveSingleton<span class="built_in"> instance </span>= (StarveSingleton) inputStream.readObject();</span><br><span class="line">//输出false</span><br><span class="line">        System.out.println(starveSingleton == instance);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出序列化可以破坏单例模式。</p><h1 id="如何防止单例模式被破坏"><a href="#如何防止单例模式被破坏" class="headerlink" title="如何防止单例模式被破坏"></a>如何防止单例模式被破坏</h1><h2 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h2><p>&emsp;&emsp;可以在构造函数里配置一个标志位，当构造函数被第二次调用时报错</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class StarveSingleton implements Serializable &#123;</span><br><span class="line">//设置flag</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> boolean flag = false;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> StarveSingleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>StarveSingleton();</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> StarveSingleton() &#123;</span><br><span class="line">        synchronized (StarveSingleton.class) &#123;</span><br><span class="line">//第一次调用的时候更改该变量的值，第二次再调用会报错</span><br><span class="line">           <span class="built_in"> if </span>(!flag) &#123;</span><br><span class="line">                flag = !flag;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               <span class="built_in"> throw </span>new RuntimeException(<span class="string">"单例模式被破坏"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> StarveSingleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(StarveSingleton.getInstance() == StarveSingleton.getInstance());</span><br><span class="line">        Class&lt;StarveSingleton&gt; clazz = StarveSingleton.class;</span><br><span class="line">        Constructor&lt;StarveSingleton&gt;<span class="keyword"> constructor</span> = clazz.getDeclaredConstructor(null);</span><br><span class="line">       <span class="keyword"> constructor</span>.setAccessible(true);</span><br><span class="line">        StarveSingleton<span class="built_in"> instance </span>=<span class="keyword"> constructor</span>.newInstance();</span><br><span class="line">        System.out.println(instance == StarveSingleton.getInstance());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样就解决了反射破坏单例的问题。</p><h2 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h2><p>&emsp;&emsp;对于序列化来说，需要实现readSolve()方法来保证每次返回的都是一个实例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class StarveSingleton implements Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    private static StarveSingleton<span class="built_in"> instance </span>= new StarveSingleton();</span><br><span class="line"></span><br><span class="line">    private StarveSingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static StarveSingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object readResolve() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);</span><br><span class="line">        StarveSingleton starveSingleton = StarveSingleton.getInstance();</span><br><span class="line">        objectOutputStream.writeObject(starveSingleton);</span><br><span class="line"></span><br><span class="line">        byte[] bytes = outputStream.toByteArray();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));</span><br><span class="line">        StarveSingleton<span class="built_in"> instance </span>= (StarveSingleton) inputStream.readObject();</span><br><span class="line">        System.out.println(starveSingleton == instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;readResolve方法是ObjectInputStream类进行反序列化的一个特殊机制，这里后续再展开，总之这里实现该方法可以保证单例不被破坏。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;下面是我对这个知识点的心得。如何破坏单例模式，这道题怎么思考呢？单例模式和创建对象相关，我们知道创建对象有4种方式</p><ol><li>直接new</li><li>调用clone方法</li><li>序列化反序列化</li><li>反射</li></ol><p>其中方式1已经被单例模式限制住，方式2我们一般很少实现clone接口，所以可以破坏单例模式的方法就从3，4而来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模式是否安全&quot;&gt;&lt;a href=&quot;#单例模式是否安全&quot; class=&quot;headerlink&quot; title=&quot;单例模式是否安全&quot;&gt;&lt;/a&gt;单例模式是否安全&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在&lt;a href=&quot;https://yajian.github.io
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yajian.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yajian.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://yajian.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yajian.github.io/设计模式-单例模式/</id>
    <published>2018-07-19T06:38:43.000Z</published>
    <updated>2018-08-06T02:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>&emsp;&emsp;单例模式是比较常用的设计模式之一，单例对象的类必须保证全局只有一个实例存在。其实现方式有很多种，本篇博客主要介绍常见的几种实现方式。</p><p>&emsp;&emsp;单例模式最基本的原则：保证该类构造方法的访问权限为private。</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>&emsp;&emsp;饿汉模式是指类初始化的时候先创建好该类实例，获取实例的时候总是返回该实例。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class StarveSingleton &#123;</span><br><span class="line"></span><br><span class="line">//先产生实例</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> StarveSingleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>StarveSingleton();</span><br><span class="line">    //保证构造函数私有化，这样无法从外部初始化该类</span><br><span class="line">   <span class="keyword"> private</span> StarveSingleton()&#123;&#125;</span><br><span class="line">//提供获取实例方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> StarveSingleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>&emsp;&emsp;懒汉模式可以延迟类的初始化，即类加载阶段不进行初始化操作，只在第一次使用单例类的时候进行初始化，主要用于一些类初始化开销比较大的情况。<br>&emsp;&emsp;缺点：多线程情况下需要特殊处理。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化是该引用为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取类实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">//第一次调用getInstance方法时，完成初始化</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>&emsp;&emsp;饿汉模式不能实现延迟加载，占用内存；懒汉模式需要进行线程安全控制，并且影响性能。这时候静态内部类模式提供了另一种比较好的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticSingleton STATIC_SINGLETON = <span class="keyword">new</span> StaticSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取类实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.STATIC_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于外部类的初始化并不会引发静态内部类SingletonHolder的初始化，所以只有在第一次调用getInstance方法时才会触发静态内部类的初始化，从而完成实例化工程。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>&emsp;&emsp;枚举类是目前比较推荐的实现单例的方案，因为枚举类实现简单，并且可以保证线程安全和序列化的安全。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Instance;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双检锁"><a href="#双检锁" class="headerlink" title="双检锁"></a>双检锁</h2><p>&emsp;&emsp;前面提到过懒汉模式可能会遇到线程安全问题，双检索实现方式可以保证线程安全和延迟初始化。但是该模式只能保证在1.5版本之后的jvm上运行的效果。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DoubleCheckSignelton &#123;</span><br><span class="line">//引用设置为空，并且用volatile修饰</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> volatile DoubleCheckSignelton<span class="built_in"> instance </span>= null;</span><br><span class="line">//私有化构造方法</span><br><span class="line">   <span class="keyword"> private</span> DoubleCheckSignelton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">//提供获取实例方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> DoubleCheckSignelton getInstance() &#123;</span><br><span class="line">//第一次判断引用是否为空</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">//防止多条线程同时实例化该类，所以加锁</span><br><span class="line">            synchronized (DoubleCheckSingleton.class) &#123;</span><br><span class="line">//此时有可能其他线程已经完成了实例化，所以再进行一次非空检测，确认是否需要进行类的实例化</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">//确认没有进行过实例化，new一个新实例</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>DoubleCheckSignelton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比枚举实现方式，双检索复杂一些。其中instance必须要用volatile修饰，此处的volatile并不是为了保证可见性，而是为了禁止重排序。产生新实例的时候一般按照开辟内存空间-创建实例-引用指向实例内存地址，但是重排序可能会将这个顺序改为开辟内存空间-引用指向实例内存地址-创建实例，如果一个线程按照第二种顺序进行操作，最后创建实例出现了问题，没有完成创建对象的工作，下一个线程进行非空检测时发现引用已经指向了新的实例地址，认为初始化工作已完成，直接返回了该引用，但实际上无法使用该实例。所以需要volatile保证类的初始化顺序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;以上就是常见的实现单例模式的方法，但是上述模式并不能完全保证全局只有一个实例，下一篇我们将深入地讲解哪些操作可以破坏单例模式，以及如何防止这些情况的发生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;单例模式是比较常用的设计模式之一，单例对象的类必须保证全局只有一个实例存在。其实现方式有很多种，本篇
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yajian.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yajian.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java多线程-Unsafe</title>
    <link href="http://yajian.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Unsafe/"/>
    <id>http://yajian.github.io/java多线程-Unsafe/</id>
    <published>2018-07-13T02:45:53.000Z</published>
    <updated>2018-07-19T03:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unsafe类解析"><a href="#Unsafe类解析" class="headerlink" title="Unsafe类解析"></a>Unsafe类解析</h1><h2 id="Unsafe类简介"><a href="#Unsafe类简介" class="headerlink" title="Unsafe类简介"></a>Unsafe类简介</h2><p>&emsp;&emsp;Unsafe类位于sun.misc包下，Unsafe类可以直接操作内存，并提供了无锁并发的实现方式CAS（compare and swap)，juc包下的大部分工具都是基于该类实现，所以要想深入理解juc必须先要了解Unsafe。然而Java官方并不建议使用该类，所以我们无法在程序进行调用，需要通过反射机制进行调用。</p><h2 id="Unsafe类使用"><a href="#Unsafe类使用" class="headerlink" title="Unsafe类使用"></a>Unsafe类使用</h2><p>&emsp;&emsp;查看源码，会发现该类的构造方法是private的，这意味这我们无法通过直接创建该类的示例。但是其内部有这样一个类变量，并且提供了访问方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>我们先尝试直接调用getUnsafe方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> testUnsafe() &#123;</span><br><span class="line">        </span><br><span class="line">        Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.<span class="string">SecurityException:</span> Unsafe</span><br><span class="line">at sun.misc.Unsafe.getUnsafe(Unsafe.<span class="string">java:</span><span class="number">90</span>)</span><br></pre></td></tr></table></figure><p>结果发现程序报错，java不允许我们直接调用该类，所以这时候需要采用特殊手段，即通过反射方式获取theUsafe类变量。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUnsafe</span>(<span class="params"></span>) throws NoSuchFieldException, IllegalAccessException</span> &#123;</span><br><span class="line"></span><br><span class="line">    Field field = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Unsafe <span class="keyword">unsafe</span> = (Unsafe) field.<span class="keyword">get</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>&emsp;&emsp;该类最重要的方法就是CAS相关方法，通过这些方法可以实现无锁并发。</p><p>&emsp;&emsp;锁可以按照策略分为乐观锁和悲观锁，悲观锁认为每次访问共享资源都会发生冲突，所以需要对每一次数据访问加锁。而乐观锁认为共享资源的访问不会总是发生冲突，没有冲突的时候线程继续执行，一旦发生冲突，通过CAS技术保证线程安全。</p><p>&emsp;&emsp;CAS的核心思想是维护三个值，即待更新变量、预期值、新值，如果待更新变量的值等于预期值，则将其更新为新值，否则说明该值已经被其他线程修改，此时不执行更新操作。</p><p>&emsp;&emsp;Unsafe中，比较常用的cas方法有</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1是待更新对象，var2是对象内存的偏移量，通过偏移量获取该字段的值，var4是预期值，var5是要设置的值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapObject(<span class="keyword">Object</span> var1, <span class="keyword">long</span> var2, <span class="keyword">Object</span> var4, <span class="keyword">Object</span> var5);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapInt(<span class="keyword">Object</span> var1, <span class="keyword">long</span> var2, <span class="built_in">int</span> var4, <span class="built_in">int</span> var5);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="built_in">boolean</span> compareAndSwapLong(<span class="keyword">Object</span> var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;1.8中还新增了下面几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定对象和字段偏移量，将其增加var4，这里需要注意，是先get再add，返回值是get的值，不返回add后的值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> var5;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">       &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">       <span class="keyword">return</span> var5;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，只不过把类型变成long</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> var6;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">       &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var6;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定对象和字段偏移量，将其设置为var4，这里需要注意，是先get再set，返回值是get的值，不返回set后的值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> var5;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">       &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var5;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，只不过把类型变成long</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> var6;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">       &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var4));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var6;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4)</span> </span>&#123;</span><br><span class="line">       Object var5;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           var5 = <span class="keyword">this</span>.getObjectVolatile(var1, var2);</span><br><span class="line">       &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapObject(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var5;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="类、对象、变量操作方法"><a href="#类、对象、变量操作方法" class="headerlink" title="类、对象、变量操作方法"></a>类、对象、变量操作方法</h3><p>&emsp;&emsp;上述方法中都用到了偏移量，那么偏移量是如何获取的？Unsafe类中提供了很多关于对象、对象、变量的操作方法，可以让我们方便地获取目标字段的偏移量。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取静态属性偏移量，用于类中静态属性的读写</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字段var1在示例对象中的偏移量</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值是f.getDeclaringClass()</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function">Object <span class="title">staticFieldBase</span><span class="params">(Field var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得给定对象偏移量上的int值，所谓的偏移量可以简单理解为指针指向该变量的内存地址，通过偏移量便可得到该对象的变量，进行各种操作</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置给定对象上偏移量的int值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得给定对象偏移量上的引用类型的值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function">Object <span class="title">getObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置给定对象偏移量上的引用类型的值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他基本数据类型(long,char,byte,float,double)的操作与getInthe及putInt相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置给定对象的int值，使用volatile语义，即设置后立马更新到内存对其他线程可见</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">putIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得给定对象的指定偏移量offset的int值，使用volatile语义，总能获取到最新的int值。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他基本数据类型(long,char,byte,float,double)的操作与putIntVolatile及getIntVolatile相同，引用类型putObjectVolatile也一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与putIntVolatile一样，但要求被操作字段必须有volatile修饰</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">putOrderedInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//分配内存指定大小的内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据给定的内存地址address设置重新分配指定大小的内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于释放allocateMemory和reallocateMemory申请的内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将指定对象的给定offset偏移量内存块中的所有字节设置为固定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置给定内存地址的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">putAddress</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定内存地址的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">long</span> <span class="title">getAddress</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置给定内存地址的long值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">putLong</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定内存地址的long值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置或获取指定内存的byte值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">byte</span>  <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span>  <span class="title">putByte</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">byte</span> x)</span></span>;</span><br><span class="line"><span class="comment">//其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作系统的内存页大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>&emsp;&emsp;Unsafe还提供了新建对象的方法，需要注意的是该方法并不会调用对象的构造方法。所以创建对象的方式一共有5种，并不是流传最广的4种。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function">Object <span class="title">allocateInstance</span><span class="params">(Class cls)</span> <span class="keyword">throws</span> InstantiationException</span>;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws NoSuchFieldException, IllegalAccessException, InstantiationException</span> &#123;</span><br><span class="line">       Field field = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">       field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">       Unsafe <span class="keyword">unsafe</span> = (Unsafe) field.<span class="keyword">get</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过allocateInstance创建对象</span></span><br><span class="line">       User user = (User) <span class="keyword">unsafe</span>.allocateInstance(User.class);</span><br><span class="line"></span><br><span class="line">       Class userClass = user.getClass();</span><br><span class="line">       Field age = userClass.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">       Field name = userClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">       Field id = userClass.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">unsafe</span>.putInt(user, <span class="keyword">unsafe</span>.objectFieldOffset(age), <span class="number">18</span>);</span><br><span class="line">       <span class="keyword">unsafe</span>.putObject(user, <span class="keyword">unsafe</span>.objectFieldOffset(name), <span class="string">"android TV"</span>);</span><br><span class="line"></span><br><span class="line">       Object staticFieldBase = <span class="keyword">unsafe</span>.staticFieldBase(id);</span><br><span class="line">       System.<span class="keyword">out</span>.println(<span class="string">"staticBase:"</span> + staticFieldBase);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取静态变量id的偏移量</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> staticOffset = <span class="keyword">unsafe</span>.staticFieldOffset(id);</span><br><span class="line">       System.<span class="keyword">out</span>.println(<span class="string">"设置前的ID:"</span> + <span class="keyword">unsafe</span>.getObject(staticFieldBase, staticOffset));</span><br><span class="line">       <span class="comment">//此处需要使用staticFieldBase返回的结果</span></span><br><span class="line">       <span class="keyword">unsafe</span>.putObject(staticFieldBase, staticOffset, <span class="string">"ssss"</span>);</span><br><span class="line">       <span class="comment">//获取静态变量的值</span></span><br><span class="line">       System.<span class="keyword">out</span>.println(<span class="string">"设置前的ID:"</span> + <span class="keyword">unsafe</span>.getObject(staticFieldBase, staticOffset));</span><br><span class="line">       <span class="comment">//输出USER</span></span><br><span class="line">       System.<span class="keyword">out</span>.println(<span class="string">"输出USER:"</span> + user.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> data = <span class="number">1000</span>;</span><br><span class="line">       <span class="keyword">byte</span> size = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">long</span> memeryAddress = <span class="keyword">unsafe</span>.allocateMemory(size);</span><br><span class="line">       <span class="keyword">unsafe</span>.putAddress(memeryAddress, data);</span><br><span class="line">       <span class="keyword">long</span> addrData = <span class="keyword">unsafe</span>.getAddress(memeryAddress);</span><br><span class="line">       System.<span class="keyword">out</span>.println(<span class="string">"addrData:"</span>+addrData);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 输出结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">staticBase:class self.unsafe.User</span></span><br><span class="line"><span class="comment">设置前的ID:USE_ID</span></span><br><span class="line"><span class="comment">设置前的ID:ssss</span></span><br><span class="line"><span class="comment">输出USER:User&#123;name='android TV', age=18, id=ssss'&#125;</span></span><br><span class="line"><span class="comment">addrData:1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"user 构造方法调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String id = <span class="string">"USE_ID"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span>(<span class="params"><span class="keyword">int</span> age</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getId</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setId</span>(<span class="params">String id</span>)</span> &#123;</span><br><span class="line">        User.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", id="</span> + id + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/javazejian/article/details/72772470" target="_blank" rel="noopener">Java并发编程-无锁CAS与Unsafe类及其并发包Atomic</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unsafe类解析&quot;&gt;&lt;a href=&quot;#Unsafe类解析&quot; class=&quot;headerlink&quot; title=&quot;Unsafe类解析&quot;&gt;&lt;/a&gt;Unsafe类解析&lt;/h1&gt;&lt;h2 id=&quot;Unsafe类简介&quot;&gt;&lt;a href=&quot;#Unsafe类简介&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://yajian.github.io/categories/java/"/>
    
    
      <category term="java源码解读" scheme="http://yajian.github.io/tags/java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>java多线程实践-CountDownLatch</title>
    <link href="http://yajian.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E8%B7%B5-CountDownLatch/"/>
    <id>http://yajian.github.io/java多线程实践-CountDownLatch/</id>
    <published>2018-06-27T02:53:57.000Z</published>
    <updated>2018-12-14T10:29:43.605Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;java多线程及并发包的知识点很多，在日常工作中很少用到，所以很难有较深刻的理解。这段时间计划深入学习一下juc，在深入源码前，先弄清楚每个类的用途，死记硬背不如找一个容易理解的例子来加深印象。</p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>&emsp;&emsp; CountDownLatch称之为闭锁，主要用于等待一组线程执行完毕再统一执行后面的程序，这样描述比较乏味难以记忆，在网上看到一个比较好的例子，拿过来分享一下。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>每天起早贪黑的上班，父母每天也要上班，话说今天定了个饭店，一家人一起吃个饭，通知大家下班去饭店集合。假设：3个人在不同的地方上班，必须等到3个人到场才能吃饭，用程序如何实现呢？</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                fatherToRes();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                motherToRes();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                meToRes();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        countDownLatch.<span class="keyword">await</span>();</span><br><span class="line">        togetherToEat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟爸爸去饭店</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fatherToRes</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"爸爸步行去饭店需要3小时。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟我去饭店</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">motherToRes</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"妈妈挤公交去饭店需要2小时。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟妈妈去饭店</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">meToRes</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"我乘地铁去饭店需要1小时。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟一家人到齐了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">togetherToEat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"一家人到齐了，开始吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;这个小例子给人的印象深刻，一下就理解了如何使用闭锁。先学会用，接下来研究一下源码。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://blog.csdn.net/lmj623565791/article/details/26626391" target="_blank" rel="noopener">Java 并发专题 ：闭锁 CountDownLatch 之一家人一起吃个饭</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;java多线程及并发包的知识点很多，在日常工作中很少用到，所以很难有较深刻的理解。这段时间计划深入学习一下juc，在深入源码前，先弄清楚每个类的用途，死记硬背不如找一个容易理解的例子来加深印象。&lt;/p&gt;
&lt;h1 id=&quot;CountDownLatch&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yajian.github.io/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yajian.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java程序获取git版本信息</title>
    <link href="http://yajian.github.io/java%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96git%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/"/>
    <id>http://yajian.github.io/java程序获取git版本信息/</id>
    <published>2018-06-25T12:10:32.000Z</published>
    <updated>2018-06-25T13:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;临近系统上线，总是频繁的更新jar包，导致并不知道测试环境正在运行哪个版本的程序，所以需要在程序中打出版本信息，这时候可以借助maven插件实现该功能。</p><h2 id="git-commit-id-plugin"><a href="#git-commit-id-plugin" class="headerlink" title="git-commit-id-plugin"></a>git-commit-id-plugin</h2><p>&emsp;&emsp;git-commit-id-plugin插件，该插件可以获取git分支、版本号、提交时间等信息，该插件的中文文档较少，具体细节可以参考官方github: <a href="https://github.com/ktoso/maven-git-commit-id-plugin" target="_blank" rel="noopener">maven-git-commit-id-plugin</a></p><p>&emsp;&emsp;在我的程序中，配置如下</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="params">&lt;plugin&gt;</span></span><br><span class="line">                <span class="params">&lt;groupId&gt;</span>pl.project13.maven<span class="params">&lt;/groupId&gt;</span></span><br><span class="line">                <span class="params">&lt;artifactId&gt;</span>git-commit-id-plugin<span class="params">&lt;/artifactId&gt;</span></span><br><span class="line">                <span class="params">&lt;version&gt;</span><span class="number">2.2</span><span class="number">.4</span><span class="params">&lt;/version&gt;</span></span><br><span class="line">                <span class="params">&lt;executions&gt;</span></span><br><span class="line">                    <span class="params">&lt;execution&gt;</span></span><br><span class="line">                        <span class="params">&lt;id&gt;</span>get-the-git-infos<span class="params">&lt;/id&gt;</span></span><br><span class="line">                        <span class="params">&lt;goals&gt;</span></span><br><span class="line">                            <span class="params">&lt;goal&gt;</span>revision<span class="params">&lt;/goal&gt;</span></span><br><span class="line">                        <span class="params">&lt;/goals&gt;</span></span><br><span class="line">                    <span class="params">&lt;/execution&gt;</span></span><br><span class="line">                <span class="params">&lt;/executions&gt;</span></span><br><span class="line">                <span class="params">&lt;configuration&gt;</span></span><br><span class="line">                    <span class="params">&lt;dotGitDirectory&gt;</span>$&#123;project.basedir&#125;/.git<span class="params">&lt;/dotGitDirectory&gt;</span></span><br><span class="line">                    <span class="params">&lt;prefix&gt;</span>git<span class="params">&lt;/prefix&gt;</span></span><br><span class="line">                    <span class="params">&lt;verbose&gt;</span>false<span class="params">&lt;/verbose&gt;</span></span><br><span class="line">                    <span class="comment">//是否单独生成properties文件</span></span><br><span class="line">                    <span class="params">&lt;generateGitPropertiesFile&gt;</span>true<span class="params">&lt;/generateGitPropertiesFile&gt;</span></span><br><span class="line">                    <span class="comment">//生成文件路径</span></span><br><span class="line">                    <span class="params">&lt;generateGitPropertiesFilename&gt;</span>$&#123;project.build.outputDirectory&#125;/git.properties<span class="params">&lt;/generateGitPropertiesFilename&gt;</span></span><br><span class="line">                    <span class="params">&lt;format&gt;</span>json<span class="params">&lt;/format&gt;</span></span><br><span class="line">                    <span class="params">&lt;gitDescribe&gt;</span></span><br><span class="line">                        <span class="params">&lt;skip&gt;</span>false<span class="params">&lt;/skip&gt;</span></span><br><span class="line">                        <span class="params">&lt;always&gt;</span>false<span class="params">&lt;/always&gt;</span></span><br><span class="line">                        <span class="params">&lt;dirty&gt;</span>-dirty<span class="params">&lt;/dirty&gt;</span></span><br><span class="line">                    <span class="params">&lt;/gitDescribe&gt;</span></span><br><span class="line">                <span class="params">&lt;/configuration&gt;</span></span><br><span class="line">            <span class="params">&lt;/plugin&gt;</span></span><br></pre></td></tr></table></figure><h2 id="templating-maven-plugin"><a href="#templating-maven-plugin" class="headerlink" title="templating-maven-plugin"></a>templating-maven-plugin</h2><p>&emsp;&emsp;已经生成了properties文件，在程序中读取该文件进行输出就可以完成任务，在开发环境中确实如此，但是到了线上环境输出却变成了null，最后也没找到原因。所以我采取了替代方案，产生version.java代码。<br>&emsp;&emsp;templating-maven-plugin插件可以自动编译/src/main/java-templates文件夹下的代码模版，并替换其中的变量，我的模版如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Version</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> BRANCH = <span class="string">"<span class="subst">$&#123;git.branch&#125;</span>"</span>;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> VERSION = <span class="string">"<span class="subst">$&#123;git.build.version&#125;</span>"</span>;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> COMMIT_ID = <span class="string">"<span class="subst">$&#123;git.commit.id&#125;</span>"</span>;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> COMMIT_TIME = <span class="string">"<span class="subst">$&#123;git.commit.time&#125;</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mvn compile后该类回出现在generate-resources文件夹下，可以被直接引用，从而实现输出版本号的功能。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">logger</span><span class="selector-class">.info</span>("<span class="selector-tag">ferrari</span> <span class="selector-tag">branch</span>: &#123;&#125;", <span class="selector-tag">Version</span><span class="selector-class">.BRANCH</span>);</span><br><span class="line">    <span class="selector-tag">logger</span><span class="selector-class">.info</span>("<span class="selector-tag">ferrari</span> <span class="selector-tag">version</span>: &#123;&#125;", <span class="selector-tag">Version</span><span class="selector-class">.VERSION</span>);</span><br><span class="line">    <span class="selector-tag">logger</span><span class="selector-class">.info</span>("<span class="selector-tag">ferrari</span> <span class="selector-tag">commit</span> <span class="selector-tag">time</span>: &#123;&#125;", <span class="selector-tag">Version</span><span class="selector-class">.COMMIT_TIME</span>);</span><br><span class="line">    <span class="selector-tag">logger</span><span class="selector-class">.info</span>("<span class="selector-tag">ferrari</span> <span class="selector-tag">commit</span> <span class="selector-tag">id</span>: &#123;&#125;", <span class="selector-tag">Version</span><span class="selector-class">.COMMIT_ID</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;临近系统上线，总是频繁的更新jar包，导致并不知道测试环境正在运行哪个版本的程序，所以需要在程序中打出版本信息，这时候可以借助maven插件实现该功能。&lt;/p&gt;
&lt;h2 id=&quot;git-commit-id-plugin&quot;&gt;&lt;a href=&quot;#git-
      
    
    </summary>
    
      <category term="java" scheme="http://yajian.github.io/categories/java/"/>
    
    
      <category term="工作中的问题" scheme="http://yajian.github.io/tags/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java源码解读--hashtable</title>
    <link href="http://yajian.github.io/java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-hashtable/"/>
    <id>http://yajian.github.io/java源码解读-hashtable/</id>
    <published>2018-06-21T10:10:02.000Z</published>
    <updated>2018-06-21T10:11:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>HashTable类早期jdk对哈希表的实现，后续加入了HashMap等新的哈希表实现，目前HashTable已经被建议弃用。</p><p>HashTable和HashMap的区别有以下几点：</p><ol><li>HashTable基于Dictionary抽象类实现了Map接口，而HashMap基于AbstractMap实现了Map接口</li><li>HashMap允许key和value为null，而HashTable中不允许</li><li>HashTable是线程安全的，HashMap不是，但Collections类中提供饿了synchronizedMap方法对HashMap进行线程安全封装</li></ol><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>继承了Dictionary抽象类，实现了</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层存储数组</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表大小</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//修改次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入初始容量和负载因子</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">           initialCapacity = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认负载因子是0.75</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, <span class="number">0.75</span>f);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//默认初始容量是11，负载因子是0.75</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75</span>f);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75</span>f);</span><br><span class="line">       putAll(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>方法被synchronized修饰，线程安全。<br>对value进行进行非空检查，若为空，报错</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> synchronized V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">//value为空报错</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"><span class="comment">//若key为空，这里会报空指针异常</span></span><br><span class="line">       <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">       <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">       @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">       Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line"><span class="comment">//检查是否需要覆盖</span></span><br><span class="line">       <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.<span class="keyword">equals</span>(key)) &#123;</span><br><span class="line">               V old = entry.<span class="keyword">value</span>;</span><br><span class="line">               entry.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">               <span class="keyword">return</span> old;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//出现冲突采用拉链法处理</span></span><br><span class="line">       addEntry(hash, key, <span class="keyword">value</span>, index);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>get方法也被synchronized修饰，线程安全</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"><span class="comment">//key为null这里会报空指针异常</span></span><br><span class="line">       <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line"><span class="comment">//计算下标</span></span><br><span class="line">       <span class="built_in">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="comment">//查找key</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.<span class="built_in">key</span>.equals(<span class="built_in">key</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> (V)e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public synchronized V remove(Object <span class="built_in">key</span>) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="type">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    for(Entry&lt;K,V&gt; <span class="built_in">prev</span> = <span class="built_in">null</span> ; e != <span class="built_in">null</span> ; <span class="built_in">prev</span> = e, e = e.<span class="built_in">next</span>) &#123;</span><br><span class="line">        if ((e.hash == hash) &amp;&amp; e.<span class="built_in">key</span>.equals(<span class="built_in">key</span>)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            if (<span class="built_in">prev</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line">                <span class="built_in">prev</span>.<span class="built_in">next</span> = e.<span class="built_in">next</span>;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tab[index] = e.<span class="built_in">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">count</span>--;</span><br><span class="line">            V oldValue = e.<span class="built_in">value</span>;</span><br><span class="line">            e.<span class="built_in">value</span> = <span class="built_in">null</span>;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容相关"><a href="#扩容相关" class="headerlink" title="扩容相关"></a>扩容相关</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">private</span> void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"><span class="comment">//如果元素个数超过扩容阈值</span></span><br><span class="line">       <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line"><span class="comment">//创建新数组，并把老数组元素复制过来</span></span><br><span class="line">           rehash();</span><br><span class="line"></span><br><span class="line">           tab = table;</span><br><span class="line">           hash = key.hashCode();</span><br><span class="line">           index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Creates the new entry.</span></span><br><span class="line">       @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">       Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">       tab[index] = <span class="keyword">new</span> <span class="type">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">       count++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   protected void rehash() &#123;</span><br><span class="line">       int oldCapacity = table.length;</span><br><span class="line">       Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容一倍+1</span></span><br><span class="line">       int <span class="keyword">new</span><span class="type">Capacity</span> = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">               <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           <span class="keyword">new</span><span class="type">Capacity</span> = MAX_ARRAY_SIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       Entry&lt;?,?&gt;[] <span class="keyword">new</span><span class="type">Map</span> = <span class="keyword">new</span> <span class="type">Entry</span>&lt;?,?&gt;[<span class="keyword">new</span><span class="type">Capacity</span>];</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       threshold = (int)Math.min(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span><span class="type">Map</span>;</span><br><span class="line"><span class="comment">//按照顺序依此复制</span></span><br><span class="line">       <span class="keyword">for</span> (int i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = old;</span><br><span class="line">               old = old.next;</span><br><span class="line"></span><br><span class="line">               int index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % <span class="keyword">new</span><span class="type">Capacity</span>;</span><br><span class="line"><span class="comment">//新插入的节点位于桶，之前插入的节点在链表上</span></span><br><span class="line">               e.next = (Entry&lt;K,V&gt;)<span class="keyword">new</span><span class="type">Map</span>[index];</span><br><span class="line">               <span class="keyword">new</span><span class="type">Map</span>[index] = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashTable&quot;&gt;&lt;a href=&quot;#HashTable&quot; class=&quot;headerlink&quot; title=&quot;HashTable&quot;&gt;&lt;/a&gt;HashTable&lt;/h1&gt;&lt;p&gt;HashTable类早期jdk对哈希表的实现，后续加入了HashMap等新的哈希表实
      
    
    </summary>
    
      <category term="java" scheme="http://yajian.github.io/categories/java/"/>
    
    
      <category term="java源码解读" scheme="http://yajian.github.io/tags/java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>java源码解读--weakhashmap</title>
    <link href="http://yajian.github.io/java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-weakhashmap/"/>
    <id>http://yajian.github.io/java源码解读-weakhashmap/</id>
    <published>2018-06-21T10:07:00.000Z</published>
    <updated>2018-06-21T10:09:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p>WeakHasMap是针对弱引用的一个类，深入理解java虚拟机中对java引用概念进行了详细说明，在此不做重复解释。需要注意的是弱引用只存活到下一次垃圾回收之前，WeakHasMap中的键都是弱引用类型，所以该类可以自动移除已经被回收的键所对应的k-v对。</p><ul><li>该类支持null值输入</li><li>默认每次扩容一倍</li><li>fail-fast</li></ul><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>继承了AbstractMap类，实现了Map接口，注意该类没有实现cloneable、serializable接口</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure><h2 id="类变量和成员变量"><a href="#类变量和成员变量" class="headerlink" title="类变量和成员变量"></a>类变量和成员变量</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始容量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认负载因子</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"><span class="comment">//底层存储结构</span></span><br><span class="line">   Entry&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//数组大小</span></span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">float</span> loadFactor;</span><br><span class="line"><span class="comment">//referencequeue用于弱引用的回收</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;<span class="keyword">Object</span>&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"><span class="comment">//修改次数</span></span><br><span class="line">   <span class="built_in">int</span> modCount;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Initial Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load factor: "</span>+</span><br><span class="line">                                              loadFactor);</span><br><span class="line"><span class="comment">//大于initialCapacity最小的2的幂次</span></span><br><span class="line">       <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">           capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="comment">//初始化table</span></span><br><span class="line">       table = newTable(capacity);</span><br><span class="line"><span class="comment">//负载因子赋值</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">//计算扩容阈值</span></span><br><span class="line">       threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">               DEFAULT_INITIAL_CAPACITY),</span><br><span class="line">            DEFAULT_LOAD_FACTOR);</span><br><span class="line">       putAll(m);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>WeakHashMap中的entry继承了WeakReference，可以在gc时放入ReferenceQueue</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;Object&gt;</span> <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">       <span class="type">V</span> value;</span><br><span class="line">       <span class="keyword">final</span> int hash;</span><br><span class="line">       <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates new entry.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">Entry</span>(<span class="type">Object</span> key, <span class="type">V</span> value,</span><br><span class="line">             <span class="type">ReferenceQueue</span>&lt;<span class="type">Object</span>&gt; queue,</span><br><span class="line">             int hash, <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) &#123;</span><br><span class="line"><span class="comment">//这里把只关联了key，只有当key被回收时，entry才会被放入ReferenceQueue</span></span><br><span class="line">           <span class="keyword">super</span>(key, queue);</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">           <span class="keyword">this</span>.next  = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>put函数会自动调用移除已释放引用相关方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">//null值统一使用NULL_KEY代替</span></span><br><span class="line">       Object k = maskNull(key);</span><br><span class="line"><span class="comment">//获取hash值</span></span><br><span class="line">       <span class="keyword">int</span> h = hash(k);</span><br><span class="line"><span class="comment">//getTable方法会调用expungeStaleEntries()方法进行已释放引用的移除</span></span><br><span class="line">       Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line"><span class="comment">//计算下标</span></span><br><span class="line">       <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line"><span class="comment">//查找是否已经存储过该key</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.<span class="keyword">get</span>())) &#123;</span><br><span class="line">               V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">value</span> != oldValue)</span><br><span class="line">                   e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line"><span class="comment">//table不存在该key，则新建entry并放入对应下标位置</span></span><br><span class="line">       Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">       tab[i] = <span class="keyword">new</span> Entry&lt;&gt;(k, <span class="keyword">value</span>, queue, h, e);</span><br><span class="line"><span class="comment">//如果容量不够，扩容一倍</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt;= threshold)</span><br><span class="line">           resize(tab.length * <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>get方法也会自动调用清除已释放引用相关的方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="keyword">Object</span> k = maskNull(<span class="built_in">key</span>);</span><br><span class="line">    <span class="built_in">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="built_in">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.<span class="built_in">get</span>()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="expungeStaleEntries"><a href="#expungeStaleEntries" class="headerlink" title="expungeStaleEntries"></a>expungeStaleEntries</h2><p>该方法用于移除已释放元素，该类中很多方法会间接调用该方法，如size,getTable,resize,get,put </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> expungeStaleEntries() &#123;</span><br><span class="line"><span class="comment">//已经释放的弱引用会加入ReferenceQueue中，所以遍历queue</span></span><br><span class="line">       <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line"><span class="comment">//同步操作</span></span><br><span class="line">           <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">               @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="comment">//从queue取出来的是entry，这点由entry定义决定</span></span><br><span class="line">                   Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line"><span class="comment">//计算下标</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"><span class="comment">//移除逻辑</span></span><br><span class="line">               Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">               Entry&lt;K,V&gt; p = prev;</span><br><span class="line">               <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Entry&lt;K,V&gt; <span class="keyword">next</span> = p.<span class="keyword">next</span>;</span><br><span class="line">                   <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (prev == e)</span><br><span class="line">                           table[i] = <span class="keyword">next</span>;</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                           prev.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">                       <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                       <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                       e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                       <span class="keyword">size</span>--;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = <span class="keyword">next</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需传入扩容后容量</span></span><br><span class="line">   void resize(int <span class="keyword">new</span><span class="type">Capacity</span>) &#123;</span><br><span class="line"><span class="comment">//此处会调用expungeStaleEntries</span></span><br><span class="line">       Entry&lt;K,V&gt;[] oldTable = getTable();</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//创建新数组</span></span><br><span class="line">       Entry&lt;K,V&gt;[] <span class="keyword">new</span><span class="type">Table</span> = <span class="keyword">new</span><span class="type">Table</span>(<span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line"><span class="comment">//复制数据,新的顺序是原顺序的反向</span></span><br><span class="line">       transfer(oldTable, <span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line">       table = <span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (size &gt;= threshold / <span class="number">2</span>) &#123;</span><br><span class="line">           threshold = (int)(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           expungeStaleEntries();</span><br><span class="line">           transfer(<span class="keyword">new</span><span class="type">Table</span>, oldTable);</span><br><span class="line">           table = oldTable;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WeakHashMap&quot;&gt;&lt;a href=&quot;#WeakHashMap&quot; class=&quot;headerlink&quot; title=&quot;WeakHashMap&quot;&gt;&lt;/a&gt;WeakHashMap&lt;/h1&gt;&lt;p&gt;WeakHasMap是针对弱引用的一个类，深入理解java虚拟机中对
      
    
    </summary>
    
      <category term="java" scheme="http://yajian.github.io/categories/java/"/>
    
    
      <category term="java源码解读" scheme="http://yajian.github.io/tags/java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>java源码解读--treemap</title>
    <link href="http://yajian.github.io/java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-treemap/"/>
    <id>http://yajian.github.io/java源码解读-treemap/</id>
    <published>2018-06-13T02:55:54.000Z</published>
    <updated>2018-06-13T02:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>treemap可以根据key的大小存储k-v对，从而保证元素有序。treemap底层使用红黑树结构来实现。</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>继承了AbstractMap抽象类，实现了NavigableMap接口</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//k-v对数量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//修改次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//treemap中entry的定义，除了k、v还有左右父节点指针，颜色标志位</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       K <span class="built_in">key</span>;</span><br><span class="line">       V value;</span><br><span class="line">       Entry&lt;K,V&gt; left;</span><br><span class="line">       Entry&lt;K,V&gt; right;</span><br><span class="line">       Entry&lt;K,V&gt; parent;</span><br><span class="line">       <span class="built_in">boolean</span> <span class="built_in">color</span> = BLACK;</span><br><span class="line"></span><br><span class="line">       Entry(K <span class="built_in">key</span>, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">           <span class="keyword">this</span>.<span class="built_in">key</span> = <span class="built_in">key</span>;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.parent = parent;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> K getKey() &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">key</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> V getValue() &#123;</span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> V setValue(V value) &#123;</span><br><span class="line">           V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> valEquals(<span class="built_in">key</span>,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">           <span class="built_in">int</span> keyHash = (<span class="built_in">key</span>==<span class="keyword">null</span> ? <span class="number">0</span> : <span class="built_in">key</span>.hashCode());</span><br><span class="line">           <span class="built_in">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">           <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">key</span> + <span class="string">"="</span> + value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">       Entry&lt;K,V&gt; t = root;</span><br><span class="line"><span class="comment">//root是null，则构建新entry作为root节点</span></span><br><span class="line">       <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">           compare(<span class="built_in">key</span>, <span class="built_in">key</span>); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">           root = <span class="keyword">new</span> Entry&lt;&gt;(<span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">           <span class="built_in">size</span> = <span class="number">1</span>;</span><br><span class="line">           modCount++;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">int</span> cmp;</span><br><span class="line">       Entry&lt;K,V&gt; parent;</span><br><span class="line">       <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">       Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">       <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果设置了比较器，则循环查找插入点，出现相等情况则覆盖原始值</span></span><br><span class="line">           do &#123;</span><br><span class="line">               parent = t;</span><br><span class="line">               cmp = cpr.compare(<span class="built_in">key</span>, t.<span class="built_in">key</span>);</span><br><span class="line">               <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                   t = t.left;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                   t = t.right;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">           &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果没有设置比较器，则使用对象内部的compareTo方法进行比较</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">           @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">               Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="built_in">key</span>;</span><br><span class="line">           do &#123;</span><br><span class="line">               parent = t;</span><br><span class="line">               cmp = k.compareTo(t.<span class="built_in">key</span>);</span><br><span class="line">               <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                   t = t.left;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                   t = t.right;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">           &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//找到插入位置，构造新的entry</span></span><br><span class="line">       Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(<span class="built_in">key</span>, value, parent);</span><br><span class="line"><span class="comment">//判断插入左节点还是右节点</span></span><br><span class="line">       <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">           parent.left = e;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           parent.right = e;</span><br><span class="line"><span class="comment">//红黑树进行调整</span></span><br><span class="line">       fixAfterInsertion(e);</span><br><span class="line">       <span class="built_in">size</span>++;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="fixAfterInsertion"><a href="#fixAfterInsertion" class="headerlink" title="fixAfterInsertion"></a>fixAfterInsertion</h2><p>在红黑树中插入节点后，会让红黑树变得不平衡，需要调用该方法调整树结构</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   private void fixAfterInsertion<span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line"><span class="string">//</span>默认所有新插入元素为红色节点，这样不违反红黑树从根节点到叶子节点所有路径包含的黑色节点个数相同的性质</span><br><span class="line">       x.color = RED;</span><br><span class="line"><span class="string">//3</span>种情况满足一点就结束调整</span><br><span class="line"><span class="string">//1.</span>当前节点为空</span><br><span class="line"><span class="string">//2.</span>当前节点是root</span><br><span class="line"><span class="string">//3.</span>当前节点的父节点是黑色</span><br><span class="line">       while <span class="params">(x != null &amp;&amp; x != root &amp;&amp; x.parent.<span class="attr">color</span> == RED)</span> &#123;</span><br><span class="line"><span class="string">//</span>父节点是祖父节点的左节点</span><br><span class="line">           <span class="keyword">if</span> <span class="params">(parentOf(x)</span> == leftOf<span class="params">(parentOf(parentOf(x)</span>))) &#123;</span><br><span class="line"><span class="string">//y</span>是祖父节点的右节点，即叔父节点</span><br><span class="line">               Entry&lt;K,V&gt; y = rightOf<span class="params">(parentOf(parentOf(x)</span>));</span><br><span class="line"><span class="string">//</span>如果叔父节点是红色</span><br><span class="line">               <span class="keyword">if</span> <span class="params">(colorOf(y)</span> == RED) &#123;</span><br><span class="line"><span class="string">//</span>父节点颜色置为黑色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(x)</span>, BLACK);</span><br><span class="line"><span class="string">//</span>叔父节点颜色置为黑色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(y, BLACK)</span>;</span><br><span class="line"><span class="string">//</span>祖父节点置为红色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(parentOf(x)</span>), RED);</span><br><span class="line"><span class="string">//</span>重新冲祖父节点调整红黑树</span><br><span class="line">                   x = parentOf<span class="params">(parentOf(x)</span>);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line"><span class="string">//</span>如果叔父节点不存在或者为黑色</span><br><span class="line"><span class="string">//</span>如果当前节点是父节点的右节点</span><br><span class="line">                   <span class="keyword">if</span> <span class="params">(<span class="attr">x</span> == rightOf(parentOf(x)</span>)) &#123;</span><br><span class="line">                       x = parentOf<span class="params">(x)</span>;</span><br><span class="line"><span class="string">//</span>以当前节点的父节点为支点进行左旋</span><br><span class="line">                       rotateLeft<span class="params">(x)</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="string">//</span>设置父节点为黑色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(x)</span>, BLACK);</span><br><span class="line"><span class="string">//</span>设置祖父节点为红色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(parentOf(x)</span>), RED);</span><br><span class="line"><span class="string">//</span>以祖父节点为支点进行右旋</span><br><span class="line">                   rotateRight<span class="params">(parentOf(parentOf(x)</span>));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line"><span class="string">//</span>如果当前节点的左节点是祖父节点的右节点</span><br><span class="line"><span class="string">//y</span>是祖父节点的左节点，即当前节点的叔父节点</span><br><span class="line">               Entry&lt;K,V&gt; y = leftOf<span class="params">(parentOf(parentOf(x)</span>));</span><br><span class="line"><span class="string">//</span>叔父节点是红色，直接修改颜色</span><br><span class="line">               <span class="keyword">if</span> <span class="params">(colorOf(y)</span> == RED) &#123;</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(x)</span>, BLACK);</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(y, BLACK)</span>;</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(parentOf(x)</span>), RED);</span><br><span class="line">                   x = parentOf<span class="params">(parentOf(x)</span>);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line"><span class="string">//</span>如果x是父节点的左节点</span><br><span class="line">                   <span class="keyword">if</span> <span class="params">(<span class="attr">x</span> == leftOf(parentOf(x)</span>)) &#123;</span><br><span class="line">                       x = parentOf<span class="params">(x)</span>;</span><br><span class="line"><span class="string">//</span>以父节点为支点左右旋</span><br><span class="line">                       rotateRight<span class="params">(x)</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="string">//</span>设置父节点为黑色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(x)</span>, BLACK);</span><br><span class="line"><span class="string">//</span>设置祖父节点为红色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(parentOf(x)</span>), RED);</span><br><span class="line"><span class="string">//</span>以祖父节点为支点进行左旋</span><br><span class="line">                   rotateLeft<span class="params">(parentOf(parentOf(x)</span>));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       root.color = BLACK;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">       Entry&lt;K,V&gt; p = getEntry(<span class="built_in">key</span>);</span><br><span class="line">       <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//直接根据排序查找</span></span><br><span class="line">   <span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line"><span class="comment">//如果默认比较器不为空，则使用默认比较器进行比较</span></span><br><span class="line">       <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> getEntryUsingComparator(<span class="built_in">key</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">           Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) <span class="built_in">key</span>;</span><br><span class="line"><span class="comment">//默认比较器为空，则使用compareTo方法进行比较</span></span><br><span class="line">       Entry&lt;K,V&gt; p = root;</span><br><span class="line">       <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="built_in">int</span> cmp = k.compareTo(p.<span class="built_in">key</span>);</span><br><span class="line">           <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">               p = p.left;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">               p = p.right;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">public</span> V remove(Object key) &#123;</span><br><span class="line"><span class="comment">//先找到对应的entry</span></span><br><span class="line">       Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">       <span class="keyword">if</span> (p == <span class="built_in">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line"><span class="comment">//返回原value</span></span><br><span class="line">       V oldValue = p.value;</span><br><span class="line"><span class="comment">//删除entry</span></span><br><span class="line">       deleteEntry(p);</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除entry的真正实现</span></span><br><span class="line">   <span class="keyword">private</span> <span class="literal">void</span> deleteEntry(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       size--;</span><br><span class="line"><span class="comment">//若被删除节点p的左孩子和右孩子都不为空，则查找替代节点</span></span><br><span class="line">       <span class="keyword">if</span> (p.left != <span class="built_in">null</span> &amp;&amp; p.right != <span class="built_in">null</span>) &#123;</span><br><span class="line"><span class="comment">//查找p的替代节点，一般为p的右子树中最小的节点</span></span><br><span class="line">           Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">           p.key = s.key;</span><br><span class="line">           p.value = s.value;</span><br><span class="line"><span class="comment">//后继节点变成待删除节点，由于只是替换，没有真正删除节点，所以前面的树结构不用改变</span></span><br><span class="line">           p = s;</span><br><span class="line">       &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//replacement是替代节点的后继节点</span></span><br><span class="line">       Entry&lt;K,V&gt; replacement = (p.left != <span class="built_in">null</span> ? p.left : p.right);</span><br><span class="line"><span class="comment">//如果待删除节点p只有一个后继节点</span></span><br><span class="line">       <span class="keyword">if</span> (replacement != <span class="built_in">null</span>) &#123;</span><br><span class="line"><span class="comment">//把p的父节点给replacement节点</span></span><br><span class="line">           replacement.<span class="keyword">parent</span> = p.<span class="keyword">parent</span>;</span><br><span class="line"><span class="comment">//如果p是根节点，则replacement为根节点</span></span><br><span class="line">           <span class="keyword">if</span> (p.<span class="keyword">parent</span> == <span class="built_in">null</span>)</span><br><span class="line">               root = replacement;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.left)</span><br><span class="line">               p.<span class="keyword">parent</span>.left  = replacement;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               p.<span class="keyword">parent</span>.right = replacement;</span><br><span class="line"><span class="comment">//接触待删除节点的前后引用关系</span></span><br><span class="line">           p.left = p.right = p.<span class="keyword">parent</span> = <span class="built_in">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果替代节点p的节点为黑色，需要调整红黑树的结构</span></span><br><span class="line">           <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(replacement);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.<span class="keyword">parent</span> == <span class="built_in">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">           root = <span class="built_in">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//p没有子节点</span></span><br><span class="line"><span class="comment">//如果p是黑色节点，调整红黑树</span></span><br><span class="line">           <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(p);</span><br><span class="line"><span class="comment">//删除p</span></span><br><span class="line">           <span class="keyword">if</span> (p.<span class="keyword">parent</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line"><span class="comment">//解除父节点对p的饮用</span></span><br><span class="line">               <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.left)</span><br><span class="line">                   p.<span class="keyword">parent</span>.left = <span class="built_in">null</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (p == p.<span class="keyword">parent</span>.right)</span><br><span class="line">                   p.<span class="keyword">parent</span>.right = <span class="built_in">null</span>;</span><br><span class="line"><span class="comment">//解除p对父节点的饮用</span></span><br><span class="line">               p.<span class="keyword">parent</span> = <span class="built_in">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="fixAfterDeletion"><a href="#fixAfterDeletion" class="headerlink" title="fixAfterDeletion"></a>fixAfterDeletion</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span>被删除节点的为黑色时才需要进行结构调整 </span><br><span class="line">   private void fixAfterDeletion<span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line"><span class="string">//</span>如果x不是跟节点并且x的颜色是黑色</span><br><span class="line">       while <span class="params">(x != root &amp;&amp; colorOf(x)</span> == BLACK) &#123;</span><br><span class="line"><span class="string">//</span>如果x是父节点的左节点</span><br><span class="line">           <span class="keyword">if</span> <span class="params">(<span class="attr">x</span> == leftOf(parentOf(x)</span>)) &#123;</span><br><span class="line"><span class="string">//sib</span>代表兄弟节点</span><br><span class="line">               Entry&lt;K,V&gt; sib = rightOf<span class="params">(parentOf(x)</span>);</span><br><span class="line"><span class="string">//</span>如果兄弟节点是红色，删除节点后导致各条路径中黑色节点个数不一样，需要进行旋转操作</span><br><span class="line">               <span class="keyword">if</span> <span class="params">(colorOf(sib)</span> == RED) &#123;</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(sib, BLACK)</span>;</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(x)</span>, RED);</span><br><span class="line">                   rotateLeft<span class="params">(parentOf(x)</span>);</span><br><span class="line"><span class="string">//</span>兄弟节点设置为父节点的右节点</span><br><span class="line">                   sib = rightOf<span class="params">(parentOf(x)</span>);</span><br><span class="line">               &#125;</span><br><span class="line"><span class="string">//</span>如果兄弟节点的两个子节点都是黑色，此时parentof<span class="params">(x)</span>一定是红色，不管经不经过第一个<span class="keyword">if</span>的调整</span><br><span class="line">               <span class="keyword">if</span> <span class="params">(colorOf(leftOf(sib)</span>)  == BLACK &amp;&amp;</span><br><span class="line">                   colorOf<span class="params">(rightOf(sib)</span>) == BLACK) &#123;</span><br><span class="line"><span class="string">//</span>把兄弟节点设置为红色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(sib, RED)</span>;</span><br><span class="line"><span class="string">//x</span>更新为x的父节点</span><br><span class="line">                   x = parentOf<span class="params">(x)</span>;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line"><span class="string">//</span>兄弟节点的两个自节点不都是黑色</span><br><span class="line"><span class="string">//</span>如果兄弟节点的右节点是黑色</span><br><span class="line">                   <span class="keyword">if</span> <span class="params">(colorOf(rightOf(sib)</span>) == BLACK) &#123;</span><br><span class="line"><span class="string">//</span>把兄弟节点的左节点设置为黑色</span><br><span class="line">                       <span class="keyword">set</span>Color<span class="params">(leftOf(sib)</span>, BLACK);</span><br><span class="line"><span class="string">//</span>把兄弟节点设置为红色</span><br><span class="line">                       <span class="keyword">set</span>Color<span class="params">(sib, RED)</span>;</span><br><span class="line"><span class="string">//</span>以兄弟节点为支点进行右旋</span><br><span class="line">                       rotateRight<span class="params">(sib)</span>;</span><br><span class="line"><span class="string">//</span>把兄弟节点设置为x的右节点</span><br><span class="line">                       sib = rightOf<span class="params">(parentOf(x)</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="string">//</span>如果兄弟节点的两个子节点都是红色</span><br><span class="line"><span class="string">//</span>把兄弟节点颜色设置为父节点颜色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(sib, colorOf(parentOf(x)</span>));</span><br><span class="line"><span class="string">//</span>把父节点设置为黑色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(x)</span>, BLACK);</span><br><span class="line"><span class="string">//</span>把兄弟节点的右节点设置为黑色</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(rightOf(sib)</span>, BLACK);</span><br><span class="line"><span class="string">//</span>以父节点为支点进行左旋</span><br><span class="line">                   rotateLeft<span class="params">(parentOf(x)</span>);</span><br><span class="line">                   x = root;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123; <span class="string">//</span> symmetric</span><br><span class="line">               Entry&lt;K,V&gt; sib = leftOf<span class="params">(parentOf(x)</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> <span class="params">(colorOf(sib)</span> == RED) &#123;</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(sib, BLACK)</span>;</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(x)</span>, RED);</span><br><span class="line">                   rotateRight<span class="params">(parentOf(x)</span>);</span><br><span class="line">                   sib = leftOf<span class="params">(parentOf(x)</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> <span class="params">(colorOf(rightOf(sib)</span>) == BLACK &amp;&amp;</span><br><span class="line">                   colorOf<span class="params">(leftOf(sib)</span>) == BLACK) &#123;</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(sib, RED)</span>;</span><br><span class="line">                   x = parentOf<span class="params">(x)</span>;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   <span class="keyword">if</span> <span class="params">(colorOf(leftOf(sib)</span>) == BLACK) &#123;</span><br><span class="line">                       <span class="keyword">set</span>Color<span class="params">(rightOf(sib)</span>, BLACK);</span><br><span class="line">                       <span class="keyword">set</span>Color<span class="params">(sib, RED)</span>;</span><br><span class="line">                       rotateLeft<span class="params">(sib)</span>;</span><br><span class="line">                       sib = leftOf<span class="params">(parentOf(x)</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(sib, colorOf(parentOf(x)</span>));</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(parentOf(x)</span>, BLACK);</span><br><span class="line">                   <span class="keyword">set</span>Color<span class="params">(leftOf(sib)</span>, BLACK);</span><br><span class="line">                   rotateRight<span class="params">(parentOf(x)</span>);</span><br><span class="line">                   x = root;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">set</span>Color<span class="params">(x, BLACK)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TreeMap&quot;&gt;&lt;a href=&quot;#TreeMap&quot; class=&quot;headerlink&quot; title=&quot;TreeMap&quot;&gt;&lt;/a&gt;TreeMap&lt;/h1&gt;&lt;p&gt;treemap可以根据key的大小存储k-v对，从而保证元素有序。treemap底层使用红黑树结构来
      
    
    </summary>
    
      <category term="java" scheme="http://yajian.github.io/categories/java/"/>
    
    
      <category term="java源码解读" scheme="http://yajian.github.io/tags/java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
</feed>
